<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Searching & Sorting Algorithms - CS Notes For You</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        .section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: white;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        .section h3 {
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }
        .key-term {
            font-weight: bold;
            color: #764ba2;
        }
        .algorithm-box {
            background: #f0f8ff;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .comparison-box {
            background: #fffbf0;
            border-left: 4px solid #ff9800;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        table th, table td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }
        table th {
            background: #667eea;
            color: white;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1>CS Notes For You</h1>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../notes.html">Study Notes</a></li>
                <li><a href="../topics.html">Topics</a></li>
                <li><a href="../revision.html">Revision</a></li>
                <li><a href="../solutions.html">Solutions</a></li>
                <li><a href="../papers.html">Papers</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="../contribute.html">Contribute</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <h1>Searching & Sorting Algorithms</h1>

        <div class="section">
            <h3>Why Algorithms Matter</h3>
            <p>Searching and sorting are among the most fundamental operations in computing. The <span class="key-term">efficiency</span> of these algorithms can make the difference between a program that responds in milliseconds and one that takes seconds or minutes.</p>
            <p><span class="key-term">Algorithm efficiency</span> is measured by how the time and space requirements grow as the input size increases (Big O notation).</p>
        </div>

        <div class="section">
            <h3>Searching Algorithms</h3>

            <h4>Linear Search</h4>
            <p>The simplest search method: check each item one by one until you find the target or reach the end.</p>

            <div class="algorithm-box">
                <strong>Linear Search Algorithm:</strong><br>
                FOR i = 0 TO length(list)-1<br>
                &nbsp;&nbsp;IF list[i] == target<br>
                &nbsp;&nbsp;&nbsp;&nbsp;RETURN i (found at position i)<br>
                &nbsp;&nbsp;END IF<br>
                END FOR<br>
                RETURN -1 (not found)
            </div>

            <h4>Linear Search Characteristics:</h4>
            <ul>
                <li><strong>Works on:</strong> Any list, sorted or unsorted</li>
                <li><strong>Best case:</strong> O(1) - target is first item</li>
                <li><strong>Worst case:</strong> O(n) - target is last item or not present</li>
                <li><strong>Average case:</strong> O(n) - need to check roughly half the items</li>
                <li><strong>Suitable for:</strong> Small lists or unsorted data</li>
            </ul>

            <h4>Binary Search</h4>
            <p>A much faster method for <strong>sorted lists</strong>: repeatedly divide the search space in half.</p>

            <div class="algorithm-box">
                <strong>Binary Search Algorithm:</strong><br>
                SET low = 0, high = length(list) - 1<br>
                WHILE low <= high<br>
                &nbsp;&nbsp;SET mid = (low + high) / 2<br>
                &nbsp;&nbsp;IF list[mid] == target<br>
                &nbsp;&nbsp;&nbsp;&nbsp;RETURN mid<br>
                &nbsp;&nbsp;ELSE IF list[mid] < target<br>
                &nbsp;&nbsp;&nbsp;&nbsp;SET low = mid + 1<br>
                &nbsp;&nbsp;ELSE<br>
                &nbsp;&nbsp;&nbsp;&nbsp;SET high = mid - 1<br>
                &nbsp;&nbsp;END IF<br>
                END WHILE<br>
                RETURN -1 (not found)
            </div>

            <h4>Binary Search Example</h4>
            <div class="comparison-box">
                <strong>Search for 42 in [5, 12, 23, 42, 67, 89, 101]</strong><br><br>
                Step 1: mid = 42 (index 3) → Equal! Found.<br><br>
                Even in worst case with unsorted list:<br>
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] search for 10<br>
                Step 1: Check middle (5) → 10 is higher<br>
                Step 2: Check middle (8) → 10 is higher<br>
                Step 3: Check middle (9) → 10 is higher<br>
                Step 4: Check 10 → Found!<br>
                Takes 4 steps vs 10 for linear search
            </div>

            <h4>Binary Search Characteristics:</h4>
            <ul>
                <li><strong>Works on:</strong> Sorted lists only</li>
                <li><strong>Best case:</strong> O(1) - target is middle item</li>
                <li><strong>Worst case:</strong> O(log n) - exponentially faster than linear!</li>
                <li><strong>Trade-off:</strong> List must be sorted first (one-time cost)</li>
                <li><strong>Suitable for:</strong> Large sorted datasets</li>
            </ul>
        </div>

        <div class="section">
            <h3>Sorting Algorithms</h3>

            <h4>Bubble Sort</h4>
            <p>The simplest sorting algorithm: repeatedly step through the list, compare adjacent items, and swap if in wrong order.</p>

            <div class="algorithm-box">
                <strong>Bubble Sort Algorithm:</strong><br>
                FOR i = 0 TO length(list)-1<br>
                &nbsp;&nbsp;FOR j = 0 TO length(list)-i-2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;IF list[j] > list[j+1]<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP list[j] and list[j+1]<br>
                &nbsp;&nbsp;&nbsp;&nbsp;END IF<br>
                &nbsp;&nbsp;END FOR<br>
                END FOR
            </div>

            <h4>Bubble Sort Example</h4>
            <div class="comparison-box">
                <strong>Sort [5, 3, 8, 4]</strong><br><br>
                Pass 1: [3, 5, 4, 8] (largest bubbles to end)<br>
                Pass 2: [3, 4, 5, 8] (second largest in place)<br>
                Pass 3: [3, 4, 5, 8] (already sorted)<br>
                Result: [3, 4, 5, 8]
            </div>

            <h4>Bubble Sort Characteristics:</h4>
            <ul>
                <li><strong>Time complexity:</strong> O(n²) - slow for large lists</li>
                <li><strong>Space complexity:</strong> O(1) - sorts in place</li>
                <li><strong>Stable:</strong> Maintains relative order of equal elements</li>
                <li><strong>Simple:</strong> Easy to understand and implement</li>
                <li><strong>Best for:</strong> Small lists, educational purposes</li>
            </ul>

            <h4>Insertion Sort</h4>
            <p>Build a sorted array one item at a time by inserting each element into its correct position.</p>

            <div class="algorithm-box">
                <strong>Insertion Sort Algorithm:</strong><br>
                FOR i = 1 TO length(list)-1<br>
                &nbsp;&nbsp;SET key = list[i]<br>
                &nbsp;&nbsp;SET j = i - 1<br>
                &nbsp;&nbsp;WHILE j >= 0 AND list[j] > key<br>
                &nbsp;&nbsp;&nbsp;&nbsp;SET list[j+1] = list[j]<br>
                &nbsp;&nbsp;&nbsp;&nbsp;SET j = j - 1<br>
                &nbsp;&nbsp;END WHILE<br>
                &nbsp;&nbsp;SET list[j+1] = key<br>
                END FOR
            </div>

            <h4>Insertion Sort Characteristics:</h4>
            <ul>
                <li><strong>Time complexity:</strong> O(n²) - worst case, O(n) best case</li>
                <li><strong>Space complexity:</strong> O(1) - in-place sorting</li>
                <li><strong>Stable:</strong> Yes</li>
                <li><strong>Best for:</strong> Small to medium lists, nearly sorted data</li>
            </ul>

            <h4>Quick Sort</h4>
            <p>A much faster algorithm: divide and conquer approach using a pivot element.</p>

            <div class="algorithm-box">
                <strong>Quick Sort Algorithm (conceptual):</strong><br>
                IF length(list) <= 1<br>
                &nbsp;&nbsp;RETURN list<br>
                END IF<br>
                CHOOSE pivot from list<br>
                CREATE less = elements < pivot<br>
                CREATE equal = elements = pivot<br>
                CREATE greater = elements > pivot<br>
                RETURN quickSort(less) + equal + quickSort(greater)
            </div>

            <h4>Quick Sort Example</h4>
            <div class="comparison-box">
                <strong>Sort [5, 3, 8, 4, 2, 7]</strong><br><br>
                Pivot = 5:<br>
                Less: [3, 4, 2]  Equal: [5]  Greater: [8, 7]<br><br>
                Recursively sort less and greater:<br>
                Result: [2, 3, 4, 5, 7, 8]
            </div>

            <h4>Quick Sort Characteristics:</h4>
            <ul>
                <li><strong>Average time complexity:</strong> O(n log n) - very efficient!</li>
                <li><strong>Worst case:</strong> O(n²) - when pivot is always smallest/largest</li>
                <li><strong>Space complexity:</strong> O(log n) - due to recursion</li>
                <li><strong>Not stable:</strong> Equal elements may change order</li>
                <li><strong>Best for:</strong> Large lists, general-purpose sorting</li>
            </ul>
        </div>

        <div class="section">
            <h3>Algorithm Comparison</h3>
            
            <table>
                <tr>
                    <th>Algorithm</th>
                    <th>Best Case</th>
                    <th>Average Case</th>
                    <th>Worst Case</th>
                    <th>Space</th>
                    <th>Stable</th>
                </tr>
                <tr>
                    <td>Linear Search</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>N/A</td>
                </tr>
                <tr>
                    <td>Binary Search</td>
                    <td>O(1)</td>
                    <td>O(log n)</td>
                    <td>O(log n)</td>
                    <td>O(1)</td>
                    <td>N/A</td>
                </tr>
                <tr>
                    <td>Bubble Sort</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Insertion Sort</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Quick Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n²)</td>
                    <td>O(log n)</td>
                    <td>No</td>
                </tr>
            </table>
        </div>

        <div class="section">
            <h3>When to Use Each Algorithm</h3>
            
            <h4>Use Linear Search when:</h4>
            <ul>
                <li>List is small (< 100 items)</li>
                <li>List is unsorted and won't be searched repeatedly</li>
                <li>You need maximum simplicity</li>
            </ul>

            <h4>Use Binary Search when:</h4>
            <ul>
                <li>List is large and sorted</li>
                <li>You'll search the same list multiple times</li>
                <li>Speed is critical</li>
            </ul>

            <h4>Use Bubble Sort when:</h4>
            <ul>
                <li>List is small (< 50 items)</li>
                <li>Teaching or learning algorithm concepts</li>
                <li>Stability is important and data is nearly sorted</li>
            </ul>

            <h4>Use Quick Sort when:</h4>
            <ul>
                <li>You need to sort large lists quickly</li>
                <li>You have sufficient memory for recursion</li>
                <li>Stability isn't a requirement</li>
                <li>Average case performance matters most</li>
            </ul>
        </div>

        <div class="section">
            <h3>Key Revision Points</h3>
            <ul>
                <li>Linear search works on any list but is O(n)</li>
                <li>Binary search is O(log n) but requires sorted list</li>
                <li>Bubble and insertion sort are O(n²) - only for small lists</li>
                <li>Quick sort is O(n log n) on average - preferred for large lists</li>
                <li>Algorithm choice depends on data size, sort order, and stability needs</li>
                <li>Always consider time and space complexity when choosing algorithms</li>
            </ul>
        </div>
    </main>

    <footer>
        <p>&copy; 2024 CS Notes For You. All rights reserved.</p>
    </footer>
</body>
</html>
