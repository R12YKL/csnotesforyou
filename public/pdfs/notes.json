{
  "sections": [
    {
      "title": "Fundamentals",
      "notes": [
        {
          "id": "1",
          "title": "Computer Science Introduction",
          "content": "--- Slide 1 ---\n\nComputer Science\n\nIntroduction to Leaving Cert Computer Science\n- Ms Smyth\n\n\n--- Slide 2 ---\n\nThe 3 parts to Leaving Cert Computer Science\n\n\n--- Slide 3 ---\n\nComputer Science Learning Outcomes\n\nStrand 1:\n23 learnings Outcomes in Strand 1 (Practices and Principles)\n1.1 describe a systematic process for solving problems and making decisions\n1.2 explain how the power of computing enables different solutions to difficult problems \n………\n\nStrand 2:\n22 learnings Outcomes in Strand 2 (Core Concepts)\n2.1 use abstraction to describe systems and to explain the relationship between wholes and parts\nuse a range of methods for identifying patterns and abstract common features\n\n\n--- Slide 4 ---\n\nWhat will I study in computer science\n\n\n--- Slide 5 ---\n\nStrand 3 - Applied Learning Tasks ?\n\nStrand 3: Has 14 Learning Outcomes\n\n\n--- Slide 6 ---\n\nHow am I assessed in Leaving Cert Computer Science?\n\n\n--- Slide 7 ---\n\nThe Actual Leaving Certificate Exam – \u000b takes place in Late May",
          "file": "Notes/1 - Computer Science Introduction.pptx"
        },
        {
          "id": "2",
          "title": "Ethics & Computing",
          "content": "--- Slide 1 ---\n\nrelationship between computing technologies and society including issues of ethics\n\nLeaving Cert Computer Science\n\n\n--- Slide 2 ---\n\nLearning outcomes\n\n1.11 discuss the complex relationship between computing technologies and society including issues of ethics\n1.12 compare the positive and negative impacts of computing on culture and society\n\n\n--- Slide 3 ---\n\nCan you name some military inventions that have shaped our world, both positively or negatively?\nDARPA inventions\n\nthe positive and negative impact of military innovations on both society and technological developments\n\n\n--- Slide 4 ---\n\n1. Military innovations, including wartime inventions, have an overall positive impact on society and on technology.\n2. Military innovations, including wartime inventions, have an overall negative impact on society and on technology.\n3. Societies advance rapidly, from a technological point of view, when there is a strong military and especially during wartime.\n\nthe positive and negative impact of military innovations on both society and technological developments\n\n\n--- Slide 5 ---\n\nLearning outcomes\n\n1.11 discuss the complex relationship between computing technologies and society including issues of ethics\n1.12 compare the positive and negative impacts of computing on culture and society\n\n\n--- Slide 6 ---\n\nWhat is Ethics?\nmoral principles that govern a person's behaviour or the conducting of an activity.\nEthics is not a set of rules or laws.\nEthics are more personal and community held views about what is right or wrong.\n\nComputing and Ethics\n\n\n--- Slide 7 ---\n\nSelf-driving cars are already cruising the streets today. These cars will ultimately be safer and cleaner than their manual counterparts, they can’t completely avoid accidents altogether. \nHow should the car be programmed if it encounters an unavoidable accident?\nEthical Dilemma of Self Driving Cars\n\nComputing and Ethics / Self Driving Cars\n\n\n--- Slide 8 ---\n\na) Can robots or machines be programmed to be ethical? \nb) Do you believe it is preferable to hit an “old man” rather than a “female doctor”? \nd) Would these results be more useful if data was only collected in Ireland instead of worldwide? Should Irish data only be used to build cars for Irish roads?\nhttps://www.moralmachine.net/\n\nComputing and Ethics / Self Driving Cars",
          "file": "Notes/2 - Ethics & Computing.pptx"
        },
        {
          "id": "3",
          "title": "Computers Transforming Society",
          "content": "--- Slide 1 ---\n\nComputers Transforming Society\n\nImproving Lives, AI and machine Learning\n\n\n--- Slide 2 ---\n\nLearning Outcomes\n\n1.11 discuss the complex relationship between computing technologies and society including issues of ethics\n1.12 compare the positive and negative impacts of computing on culture and society\n1.13 identify important computing developments that have taken place in the last 100 years and consider emerging trends that could shape future computing technologies\n1.18recognise the diverse roles and careers that use computing technologies\n\n\n--- Slide 3 ---\n\nImpacts of computer of society\n\nThe relationship between computing technologies and society is very complex\nFor the past 70 years computing tech. has changed society faster and more dramatically than any other development.\nMany developments are positive but many have negative effects e.g. DNA matching combined with digitisation of public records has transformed our ability to research family history but can be used to find missing people or criminal suspects. This raises many ethical questions\n\n\n--- Slide 4 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan makes a number of phone calls to travel agents a month before he wants to travel\nA few days later he visits his selected travel agent and buys his return flight to New York Via London (€6,000 in todays money). His flight is 2 weeks later than he wanted but 1 month away was too expensive\n\n\n--- Slide 5 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan uses the Travel Agent to reserve a room in hotel in Manhattan for €1,000. This involves lots of paperwork. He chose his room based on a paragraph of text with no photos.\nHe pays the Travel Agent over €4,000 by cheque and still owes the travel Agent over €3,000\nHe borrows €3,000 from is father. Declan goes to the post office and posts the second cheque to the travel agent.\n\n\n--- Slide 6 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nA few days later, he phones the Travel Agent to check if the cheque had arrived.\nThe travel agent puts the tickets and hotel reservation documents in the post\nDeclan receives his tickets, etc.. 2 days before the flight.\n\n\n--- Slide 7 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDay of flight, Declan makes very expensive call to friends in New York to tell them he’s on the way. \nAt airport , he waits in several long queues where paperwork is checked and luggage dealt with\nDeclan puts paper nametags on his luggage. If they fall off or his luggage get lost, it will probably be lost forever so he keeps all valuables on him.\n\n\n--- Slide 8 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan gets his flight to London and walks around Heathrow asking people where to get the New York flight. Eventually he finds the correct gate\nHe arrives in New York and waits in Immigration queue to get passport checked\nThere’s an issue with his visa but it eventually gets sorted out\n\n\n--- Slide 9 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan has to ask people where to pick up his luggage and eventually gets sorted\nHe gets his currency exchanged at a desk at the airport and it is very expensive.\nHe buys something at a newsagents so he has change to make a phone call to his friends to arrange to meet them the following day\n\n\n--- Slide 10 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan realises he forgot to give an important file to his boss before he left. To sort this out he makes a very expensive phone call to his boss to explain where he left the file on his desk.\nHe gets a taxi to his hotel. Due to an accident blocking the road he gets out early but can’t figure out where his hotel is. He asks a passerby but they don’t understand his accent. Eventually he finds someone who can tell him where to go and he finds his hotel.\n\n\n--- Slide 11 ---\n\nA Case Study – Travelling to New York\n\n1950’s – Dublin to New York\nDeclan’s watch has stopped because he forgot to wind it. He considers buying one of those new battery operated ones but they’re very expensive\n\n\n--- Slide 12 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán booked her ticket the day before her flight. It was expensive as a result €600. She pays for it completely with her credit card.\nSiobhán applied for her ESTA (visa to visit America) in advance but it only took a few minutes\nSiobhán used the WWW to search for hotels in New York under $200 per night and finds 1,543 options\n\n\n--- Slide 13 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán uses reviews from other tourists and lots of photos of the hotel rooms to chose her hotel and room. She appreciates the photos taken by other tourists of the hotel taken only last week. She doesn’t trust the hotels own photos to show the whole story.\nSiobhan uses a comparison website to find the best price for the hotel she wants to stay in and pays for it online.\nSiobhán checks in for her flight online and gets her mobile boarding pass.\n\n\n--- Slide 14 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán emails her friends in New York with the details of her visit\nNext morning, she uses an app to book a taxi to the airport\nShe brings her bags at the automated luggage drop machine where she uses her mobile boarding pass on her phone to check her luggage in and print the luggage tag. Siobhan bought a GPS bag so she can track her luggage with her phone anywhere in the world.\n\n\n--- Slide 15 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán is a computer programmer and notes that the metal detectors, body scanners and x-ray machines are all computer systems.\nDuring takeoff, she can’t use any electronic devices. \nThe plane has free wi-fi so Siobhan researches what the winglets on the tip of the wings are for. These are an example of how computers have changed air travel. The winglets save fuel and their design was aided by cheap computational testing instead of expensive wind tunnel testing.\n\n\n--- Slide 16 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán is a computer programmer and notes that the metal detectors, body scanners and x-ray machines are all computer systems.\nDuring takeoff, she can’t use any electronic devices. \nThe plane has free wi-fi so Siobhan researches what the winglets on the tip of the wings are for. These are an example of how computers have changed air travel. The winglets save fuel and their design was aided by cheap computational testing instead of expensive wind tunnel testing.\n\n\n--- Slide 17 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán also reads an online article about a certain type of plane that has recently being grounded due to 2 crashes in which hundreds died. These were caused by faulty flight control software.\nSiobhan then watches a film on her phone\nShe researches where to visit and restaurants in New  York and books some tickets for touristy things and makes reservations for restaurant, all using her phone and the inflight wi-fi\n\n\n--- Slide 18 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán also reads an online article about a certain type of plane that has recently being grounded due to 2 crashes in which hundreds died. These were caused by faulty flight control software.\nSiobhan then watches a film on her phone\nShe researches where to visit and restaurants in New  York and books some tickets for touristy things and makes reservations for restaurant, all using her phone and the inflight wi-fi\n\n\n--- Slide 19 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhán realises she forgot to send an important file to her boss, She logs in to her companies computer system, finds the file and emails it to him.\nShe messages her friends using her phone to tell them her plans for the next few days and messages her parents to tell them she made her flight and is nearly there.\n\n\n--- Slide 20 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nThanks to her electronic visa and the e-gates in New York airport, Siobhan flys through immigration and her phone confirms her bag has arrived.\nShe doesn’t need to look at the information screens for details of where to pick up her bag as her phone tells her where to go\nShe doesn’t need to exchange currency as she will use her credit card that does it automatically\n\n\n--- Slide 21 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nShe checks her phone to find the quickest way to her hotel and this tells her what subway to use and where to change trams.\nShe pays for the subway using her phone that she holds up to the scanner at the barrier.\nOnce out of the Subway, she uses the map app on her phone to find her hotel and walks there\n\n\n--- Slide 22 ---\n\nA Case Study – Travelling to New York\n\nToday – Siobhán’s Journey\nSiobhan’s phone and watch automatically change the time zone when she arrived in New York so she can tell the local time easily\n\n\n--- Slide 23 ---\n\nComputer science is changing everything : https://www.youtube.com/watch?v=QvyTEx1wyOY\n\n\n--- Slide 24 ---\n\nImpacts of Computers on society\n\nIt’s impossible to think of one facet of modern lives that computers haven’t affected – normally, but not always, for the better \nIt is very difficult to avoid using the Internet. More and more the internet is built into our everyday experiences. The internet is expected to play an even greater part in our day to day lives\n\n\n--- Slide 25 ---\n\nMedicine and Healthcare\n\nComputing technology has greatly improved medicine and healthcare.\nMuch of modern medicine still depends on people, which carries a risk of human error. Often a diagnosis is based on the interpretation of information by a single person – and people make mistakes.\nhttps://www.youtube.com/watch?v=V680nMGpeEM&t=8s\n\n\n--- Slide 26 ---\n\nMedicine and Healthcare\n\nComputing is transforming medicine by assisting medical professionals to make a diagnosis.\n\n\n--- Slide 27 ---\n\nMedicine and Healthcare – Image recognition and classification algorithms\n\nImage recognition and classification algorithms are already being used to identify cancerous tumours in medical imaging.\nThis was done up to recently solely by people, but now with assistance from computers the chances of errors occurring can be greatly reduced.\n\n\n--- Slide 28 ---\n\nMedicine and Healthcare – Image recognition and classification algorithms\n\nThe computer pre-process the images and identify potentially cancerous tumours. A human expert can then pay extra attention to these images\nThe computer can also post-process images that were already checked by an expert to ensure nothing was missed.\n\n\n--- Slide 29 ---\n\nMedicine and Healthcare – Clinical Decision Support Systems\n\nIn Ireland, the GP, plays a central role in the healthcare system and is normally the 1st person seek medical advice\nSome GPs are already using computers to help them do their work better. One specific area that’s in a rapid state of change is clinical decision systems\n\n\n--- Slide 30 ---\n\nMedicine and Healthcare – Clinical Decision Support Systems\n\nA clinical decision support system provides doctors with assistance in making medical decisions.\nThe system can be knowledge based. The system uses information from medical literature and expert knowledge \nThe system can be based on artificial intelligence.\n\n\n--- Slide 31 ---\n\nMedicine and Healthcare – Clinical Decision Support Systems – An example\n\nPatient presents with a fever, headache and a rash on the stomach\nTraditionally the doctor must rely on their experience and knowledge (both of which may be biased and based on limited number of cases) to guide their diagnosis\nA Clinical Support System instantly draws upon symptoms and diagnosis from thousands of cases and factor them into the diagnosis\n\n\n--- Slide 32 ---\n\nMedicine and Healthcare – Clinical Decision Support Systems – An example\n\nOther not readily accessible information can be used with these systems e.g The system may prompt the doctor to ask if the patient travelled abroad recently as these 3 symptoms are common to a rare disease in some distant country\n The doctor may not have come across this disease before. Without the clinical support system, the doctor may not have considered this possibility\n\n\n--- Slide 33 ---\n\nMedicine and Healthcare – Genomics\n\nA field of molecular biology that focuses on genomes, a complete set of an organisms DNA\nSeveral thousand genetic diseases affect humans and are 1 of the main causes of infant deaths. (Downs Syndrome, Fragile X syndrome..) Identifying which genetic disease is affecting a critically ill child is very difficult and often time is of the essence\n\n\n--- Slide 34 ---\n\nMedicine and Healthcare – Genomics - Example\n\nThe Center for Pediatric Genomic Medicine in the US reported a baby suffering from liver failure for an unknown reason. The hospital used 25 hours of supercomputer time to analyse 120 Billion DNA sequences, narrowing down the cause of the illnss to two possibilities. This allowed the doctors to save the baby’s life. Without advanced computing technology the baby would have died.\n\n\n--- Slide 35 ---\n\nMedicine and Healthcare – Genomics – Screening for genetic markers\n\nScientists have identified genetic markers that can indicate a predisposition to certain diseases, including several types of cancer.\nScreening for some inherited and other genetic diseases is now common\n\n\n--- Slide 36 ---\n\nMedicine and Healthcare – Genomics – Screening for genetic markers\n\nCystic fibrosis, and Huntingdon’s disease are caused by genetic mutations. Genetic markers for these and many other diseases  are currently being researched using rapidly developing technologies.\n\n\n--- Slide 37 ---\n\nMedicine and Healthcare – Genomics – Alteration of Genetic Code\n\nIt’s technically possible to analyse and alter genetic code of humans, even before birth, to achieve many goals such as avoid some diseases.\nTechnical, LEGAL and ETHICAL issues must be overcome for these practices to become mainstream.\n\n\n--- Slide 38 ---\n\nMedicine and Healthcare – Genomics – Alteration of Genetic Code\n\nThe ability to alter genetic code means that people could potentially chose non-life threatening attributes influenced by genetics for their children (eye colour, predisposition for baldness or weight gain etc..)\nGenetic editing of human embryos is illegal or restricted in most countries. This area is fraught with ethical concerns and require legal, governmental and societal oversight\n\n\n--- Slide 39 ---\n\nTasks -\n\nComputer Science Book pg 281 Task 4\nResearch some potential future changes in genomics that computing technology many bring about.\nComputer Science book pg 293 Task 10.\n\n\n--- Slide 40 ---\n\nEncryption and Privacy\n\nEncryption refers to the use of algorithms to securely encode a message into a ciphertext.\nThe recipients have the means to decode the ciphertext back into plaintext\nEncryption allows anyone with a computer and special software to encode messages and information\n\n\n--- Slide 41 ---\n\nEncryption and Privacy\n\nIt is becoming more common for web pages to use hypertext transfer protocol secure (https). The visitor to a website using https can be relatively sure they are communicating directly with the intended website. They can be reasonably confident that any information between their computer and the websiteis safe, even if it is intercepted by a malicious actor.\n\n\n--- Slide 42 ---\n\nEncryption and Privacy\n\nMany popular messaging and social media apps also use encryption to ensure that message sent from one user to another are not readable by anyone who intercepts them\nSimilarly, industrial and military communications are often encrypted\nMany businesses use software on their computers/devices that encrypt all stored data so that if a laptop is stolen, the data can not be accessed without the correct password\n\n\n--- Slide 43 ---\n\nEncryption and Privacy\n\nThese encryptions do not just protect the data with a password but all data is also encrypted (unreadable/scrambled). The password lets the user in but also unscrambles the data so that it makes sense\n\n\n--- Slide 44 ---\n\nEncryption and the economy\n\nEncryption is also the basis of much of the world’s economy. Online banking and many other transactions rely on some form of encryption\n\n\n--- Slide 45 ---\n\nEncryption and the economy: Currency\n\nBitcoin became a household name around 2018. It is one form of cryptocurrency.\nCryptocurrency is any form of currency that exists digitally or virtually (not in physical form) and uses cryptography to secure transactions.\n\n\n--- Slide 46 ---\n\nEncryption and the economy: Currency\n\nSome advantages of digital currencies compared to physical currency (coins, paper banknotes etc..) include instant transfer, traceability and protection from traditional theft and loss.\nBitcoin is just one of thousands of types of currency.\nCryptocurrency uses decentralized control which means no one person or bank or government can control the transactions or create new units of currency.\n\n\n--- Slide 47 ---\n\nEncryption and the economy: Currency\n\nThe adoption of digital currency has been relatively slow. It is likely that society will continue to move towards digital currencies and away from current systems largely based on fiat currencies where the value is often enforced by a centralised authority.\nA weakness of fiat currencies is that its dependent on a centralised authority such as a government and in difficult times such as war, the currency can experience wild fluctuations in value.\n\n\n--- Slide 48 ---\n\nEncryption and the economy: Currency\n\nAnother weakness of fiat currencies is they require large banking systems to facilitate safekeeping, exchange and other services. This makes the use of fiat currencies expensive in comparison to digital currencies.\nhttps://www.investopedia.com/terms/c/cryptocurrency.asp\n\n\n--- Slide 49 ---\n\nJobs\n\nComputers have created thousands of job types and millions of individual jobs that a few decades ago, did not exist. Many of these jobs are directly concerned with computing technologies including:\nComputer programmers\nIT managers\nWeb designers\nSocial Media celebrities\n\n\n--- Slide 50 ---\n\nJobs\n\nA large number of jobs have also been indirectly created by computing. e.g. the rise in online shopping has led to a massive increase in parcel shipments creating many new jobs in warehousing and distribution\nMany jobs have been lost due to changes in technology. Jobs that require routine , repetitive and dangerous tasks such as assembly line work and working with hazardous materials have been eliminated and replaced with automated processes and and robotic solutions\n\n\n--- Slide 51 ---\n\nJobs\n\nRetail jobs have been lost due to online shopping\nTravel agents have been disrupted by the internet and e-commerce\n\n\n--- Slide 52 ---\n\nRemote Working\n\nDuring the pandemic many peoples jobs were saved because of technology. Technology allowed people to carry out their jobds remotely\nShifting to remote working provides flexibility and can preserve jobs but it highlights the importance of everyone having access to high speed broadband.\nRemote working can also revitalise rural towns that were struggling to survive pre-pandemic\nRemote working also benefits the environment as there is less commuting\n\n\n--- Slide 53 ---\n\nThe Environment\n\nComputing has many substantial direct effects on the environment\nNuclear Weapons Testing using supercomputers One of the most common uses of supercomputers is to accurately test and model the effects of nuclear weapons. Prior to supercomputers, live tests were the only viable option. Live nuclear tests, resulted in destructions of many areas of Earth; the production of tons of nuclear waste; the health of millions of people were affected by these nuclear tests and the displacement of many minorities and marginalised groups of people.\n\n\n--- Slide 54 ---\n\nThe Environment\n\nComputing has many substantial direct effects on the environment\nEnergy Consumption and reduction :Power consumption has become one of the largest issues of computing technology. Cryptocurrency mining uses more energy than the entire country of Ireland.\nComputers enable some processes to be more energy efficient through better control and analysis. E.g. modern electric cards would not be possible without the software that controls them. Electric cars produce fewer emissions and are more energy efficient than traditional cars.\n\n\n--- Slide 55 ---\n\nImage and facial recognition\n\nThere has been a rapid increase in the accuracy and proliferation of image and facial recognition in recent years \nThe ability to scan vehicle number plates is used for many purposes: controlling access to carparks; enforcing toll payments ;identifying car owners with outstanding arrest warrants.\nFacial recognition systems are now used to: scan airport passengers; provide access to mobile phones; match photos of similar people / family on social media platforms\n\n\n--- Slide 56 ---\n\nImage and facial recognition\n\nIn China, it is now common to pay for goods just by looking at the camera at the til.\nImage recognition and classification are used to detect skin cancers and scan people’s retinas (for biometric security/identification as well as disease\nhttps://www.youtube.com/watch?v=YX8BzK_LU0E\n\n\n--- Slide 57 ---\n\nEducation – Online Learning\n\nThere are vast quantities of online courses, instructional videos and distance and blended learning where students can study almost any subjects, at university level and lower, without leaving the comfort of their own home.\nIt is common to submit homework online. Many top universities such as Havard, MIT and Standford deliver Massive Online Open Courses (MOOC) with thousands of students . They are mainly free and available worldwide\n\n\n--- Slide 58 ---\n\nLinguistics and Communication\n\nSpeech Interpretation The main barrier to this was a lack of algorithms that could effectively, quickly and accurately interpret human speech. Human speech is extremely vague and confusing. -  \t- There are many different ways to say the same thing. \nWords that sound exactly the same, can have different meanings e.g rain, reign, reins, reindeer; two, to, too,\n\n\n--- Slide 59 ---\n\nLinguistics and Communication\n\nSpeech Interpretation As humans we are very good at interpreting the meanings but it is extremely difficult to write programs to correctly interpret speech. Recently, algorithms have been developed, and computers can now interpret speech quite accurately\nhttps://www.youtube.com/watch?v=6altVgTOf9s\n\n\n--- Slide 60 ---\n\nLinguistics and Communication\n\nAutomatic Translation\nOne way that computing has affected linguistics is by automatically translating from one language to another. It is now possible to have software on your phone that can translate  between dozens of natural languages in real time. This was only in its infancy a few years ago but it has opened up new travel and international business opportunities for millions of people.\n\n\n--- Slide 61 ---\n\nArt & Entertainment\n\nArt & entertainment has been radically impacted by computer technology. \nAnimated feature films are now entirely dependent on cutting edge technology to produce their content.  Animated films are now COMPLETELY generated by computers. Some of the scenes are so complex that high performance computing software is required to render the images. These films use tens of thousands of computer processors and hundreds of millions of CPU hours. If only a single computer was available, it would take tens of thousands of years to make a single film.\n\n\n--- Slide 62 ---\n\nDeveloping Societies, human rights and Equality\n\nOne of the greatest promises of computing technology lies in the help it may be able to give developing world. Technology may be able to locate resources such as drinking water, healthcare and education\nDigital Divide Computing technology may lead to greater inequality by increasing the gap between those that have easy and affordable access to computers and the internet and those who do not. \nThe internet is reshaping our definition of human  rights. Should access to the internet be a human right??\n\n\n--- Slide 63 ---\n\nDeveloping Societies, human rights and Equality\n\nThe internet is reshaping our definition of human  rights. Should access to the internet be a human right?? Access to the internet can: Affect freedom of speech; enable social mobility; provide the ability to earn an income; facilitate learning about potentially life-threatening matters; provide free access to medical information.\n\n\n--- Slide 64 ---\n\nDeveloping Societies, human rights and Equality\n\nInternet access depends on socio-economic status, geographical location, political environment and the local laws. \nIn 1999, only 0.04% of the world had internet access. In 2014 it had increased to 40% and by 2020 it was almost 60%\nBut the ability to access the internet is not the same from country to country\n\n\n--- Slide 65 ---\n\nMedia and social media\n\nThe internet and social media can be used to influence people. Fake news can spread easily and quickly and can affect decisions such as :\nSelecting which product to chose\nMaking important health decisions\nDetermining who to vote for in political elections.\n\n\n--- Slide 66 ---\n\nMedia and social media\n\nDeep fakes are material that artificial intelligence produces to provide fraudulent but credible looking photos, audio clips and video clips. Deep fakes proliferate the internet and have the capacity to misinform and mislead millions. \nhttps://www.youtube.com/watch?v=gLoI9hAX9dw\n\n\n--- Slide 67 ---\n\nSome questions to answer\n\nPg 293 Q15 – How might people in the developing world be empowered by computing technology\n\nPg 293 Q18 Find one positive and one negative effect computing technology can have on democratic elections.\n\nPg 293 Q20 What could the use of cyber warfare involve, if used in future conflicts.\n\n\n--- Slide 68 ---\n\nArtificial Intelligence / Machine Learning\n\nArtificial Intelligence refers to using computer systems to perform tasks that normally require human intelligence\nMachine Learning gives computers the ability to learn without being explicitly programmed\nWhat is Artificial Intelligence\nhttps://www.youtube.com/watch?v=aOP2eJWehwo&list=PLIP_AClgjRDgDqmMD5qRhrqAzVLUaeixm&index=2\n\n\n--- Slide 69 ---\n\nMachine Learning\n\nhttps://www.youtube.com/watch?v=ETfWKZIu-sk\nCheatsheet -> https://bit.ly/32qdLPH\n\n\n===== 4  Embedded Systems.pptx =====\n\n\n--- Slide 1 ---\n\nEmbedded Systems\n\nUsing the BBC Microbit\n\n\n--- Slide 2 ---\n\nWhat is an Embedded System\n\n\n--- Slide 3 ---\n\nExamples of Embedded System\n\nExamples of embedded systems include:\ncentral heating systems\nengine management systems in vehicles\ndomestic appliances, such as dishwashers, TVs and digital phones\ndigital watches\nelectronic calculators\nGPS systems\nfitness trackers\n\n\n--- Slide 4 ---\n\nProgramming the micro:bit\n\n\n--- Slide 5 ---\n\nWhat is a micro:bit\n\nBattery pack\n\nMicro-USB cable\n\nmicro:bit\n\n\n--- Slide 6 ---\n\nWhat is a micro:bit (front)\n\n1 – A and B buttons\n2 – LED display and light sensor\n3 – Pins GBIO\n4 – Pin 3 volt power\n5 – Pin Ground\n6 – Touch logo\n7 – Microphone LED\n\n\n--- Slide 7 ---\n\nWhat is a micro:bit (back)\n\n1 – Radio and Bluetooth antenna\n2 – Processor & Temperature Sensor\n3 – Compass\n4 – Accelerometer\n5 – Pins\n6 – Micro USB socket\n9 – Battery Socket\n10 – USB Interface chip\n11 – Speaker\n12 – Microphone\n13 – Red power LED\n14 – Yellow USB LED\n15 – Reset & Power button\n\n\n--- Slide 8 ---\n\nMicrobit Sensors\n\nAccelerometer – a motion sensor that measures movement. The accelerometer in your BBC micro:bit detects when you tilt it left to right, backwards and forwards and up and down.\nTemperature Sensor - An input device that measures temperature. The temperature sensor is inside the processor which can give you an approximation of the air temperature.\nLight Sensor - An input device that measures light levels. Your micro:bit uses the LEDs to sense the levels of light.\n\n\n--- Slide 9 ---\n\nMicrobit Sensors\n\nCompass – The compass is an input sensor that detects magnetic fields. The micro:bit has an inbuilt compass that can detect the direction in which it is facing.\nTouch Logo - The touch logo uses capacitive touch, sensing tiny changes in electrical fields to know when your finger is pressing it - just like your phone or tablet screen.\nMicrophone - The micro:bit has a built-in microphone. You can use it as a simple input - make your micro:bit turn the lights on when you clap. It can measure the amount of sound\n\n\n--- Slide 10 ---\n\nMicrobit Sensors\n\nRadio - Radio is a way of sending and receiving messages and BBC micro:bits can use radio waves to communicate with each other.\nPins - On the bottom edge of the micro:bit there are 25 gold strips, called pins. These pins allow you create circuits or connect external things like buzzers and motors\nButtons - Buttons are a very common input device. Your micro:bit has two buttons you can program, and a reset button\n\n\n--- Slide 11 ---\n\nMicrosoft MakeCode\n\nGo to https://makecode.microbit.org and click on New Project\n\n\n--- Slide 12 ---\n\nMicrosoft MakeCode Editor\n\nSimulator\n\nToolbox\n\nWorkspace\n\n\n--- Slide 13 ---\n\nAlgorithms\n\nAn algorithm is a sequence of instructions or a set of rules to get something done.\n\nComputer scientists strive for algorithms which solve problems in the most-effective and efficient ways – getting the most-accurate results, in the quickest time, with the fewest resources (memory or time).\n\nImage Source: codemonkey.com\n\n\n--- Slide 14 ---\n\nVariables\n\nA variable is a place where you can store and retrieve data.\n\nHere’s how to define a variable in the Block Editor:\n1. From the Variables Toolbox category select ‘Make \na Variable’ and give your variable a name. \n2. Drag the                                       and place it inside the\non start bracket.\n\n> What is a variable?\n\n\n--- Slide 15 ---\n\nVariables (contd)\n\nComplete the following blocks of code and initialise each variable to the value of 0 at the start of the programme.\n\n\n--- Slide 16 ---\n\nVariables (contd)\n\n> We need to code to update the values at each round of the game. \n\nEach time the scorekeeper presses button A to record a win for Player A, we want to add 1 to the current value of the variable PlayerAWins. \n\nWe want the same to happen when button B is pressed and also for when button A and B are pressed at the same time.\n\n\n--- Slide 17 ---\n\nWe can code our programme to display an ‘A’, ‘B’ or ‘T’ using the show leds block.\nThis will give the user visual feedback acknowledging that the user pressed a button. \nNotice that we added a clear screen block after showing ‘A’, ‘B’, or ‘T’.\n\nBasic Toolbox Category\n\n\n--- Slide 18 ---\n\nDrag out the on shake event handler block from the Input Toolbox category to trigger this event.\nAdd the show string show number pause show leds and clear screen blocks from the Basic Toolbox category and insert them into the on shake bracket as shown.\nIn the Variables Toolbox category drag out the curved variable name blocks and insert them in the corresponding show number blocks to activate them.\n\nDisplay Final Variable Values\n\n\n--- Slide 19 ---\n\nAccelerometer\n\nThe micro:bit contains an accelerometer sensor that is able to measure forces applied to the board. On earth, we are subject to the gravity force which pulls us to the ground!\nWhen the micro:bit is flat on a table, with the screen pointing up, the gravity force is aligned with the Z axis of the micro:bit.\nIf you tilt it up and down, the force will align with the Y axis – this is how we can detect tilting. If the force along Y grows, the micro:bit is tilting more and more vertically.\n\n\n--- Slide 20 ---\n\nConditionals\n\nA condition is criteria that the user must meet for a certain function to be carried out.\n\n> What is a condition?\n\nWe can add a condition to make code function in certain ways:\n\nA calculator waits for the user in input numbers and a function, before outputting a result\nA game waits for the user to press a button at the right time before outputting their score\nA quiz waits for the user to choose the correct option, and if they are wrong the quiz will tell the user\n\n> Why use a condition?\n\n\n--- Slide 21 ---\n\nConditionals (Contd)\n\nThe code inside the if block only runs when the condition block is true. You can compare variables to values or variables to variables, for a true condition.\n\nIf you want some other code to run when the opposite condition is true, you put it in an additional block area called else.\n\n\n--- Slide 22 ---\n\nBlock Code\n\nAdd an on shake block from the Input Toolbox category to run code when you shake the micro:bit\nCreate a variable called ‘hand’ and place the set hand to block in the shake event.\nAdd a pick random block from the Math Toolbox category to pick a random number from 1 to 3 and store it in the variable named ‘hand’.\n\n> Create this programme\n\n\n--- Slide 23 ---\n\nBlock Code\n\nPlace an if block form the Logic Toolbox category under the pick random and check whether ‘hand’ is equal to 1. \n\nAdd a show leds block from the Basic Toolbox category that shows a picture of a piece of paper. The number 1 will mean paper.\n\n> Create this programme\n\n\n--- Slide 24 ---\n\nBlock Code\n\nClick the (+) button to add an else section.\n\nAdd a show leds block inside the else. Make a picture of a scissors in the LEDs.\n\n> Create this programme\n\n\n--- Slide 25 ---\n\nBlock Code\n\nClick the (+) button again to add an else if section. \n\nNow, add a conditional block for hand = 2 to the condition in else if. Since ‘hand’ can only be 1, 2, or 3, your code is covering all possible cases.\n\nGet one more show leds block and put it in the else if. Make a picture of a rock in the LEDs.\n\n> Create this programme\n\n\n--- Slide 26 ---\n\nBlock Code\n\nCan you code Button A to act as a scoreboard?\n\n> Challenge A\n\n> Challenge B\n\nModify the game to use different images or to add more options like ‘Rock Paper Scissors Skull Ghost’.\n\n\n--- Slide 27 ---\n\nIterations\n\nIteration (or a loop) is the process of repeating steps.\n\n> What is iteration?\n\nIteration allows us to simplify our algorithm by stating that \nwe will repeat certain steps until told otherwise.\n\nThis makes designing algorithms quicker and simpler because \nthey don’t have to include lots of unnecessary steps.\n\n> Why use iterations?\n\nImage source: makecode.microbit.org\n\n\n--- Slide 28 ---\n\nIterations (Contd)\n\nMicrosoft MakeCode has three different loop blocks:\tRepeat block\n\tWhile block\n\tFor block\n\nYou’ll notice that the repeat block takes a parameter. The parameter tells the repeat block how many times we want the code within the block to repeat.\n\n\n--- Slide 29 ---\n\nBlock Code\n\nCreate a variable called ‘sprite’ and place the set sprite to block in the on start event handler.\nClick on the ‘advanced’ option in the toolbox category and scroll down to the game tab.\nAdd a create sprite at x:0 y:0 block from the and store it in the parameter of the set sprite to block.\n\n> Create this programme\n\n\n--- Slide 30 ---\n\nBlock Code\n\nFrom the input toolbox category drag out an on button A pressed block to your workspace.\nIn the loops toolbox category select the repeat block and leave the parameter at 4. Place this block inside the on button A pressed block.\nIn the game toolbox category drag out sprite move by block and change the parameter to 4. Also drag out the sprite turn right by block and change the parameter to 90. Place both these blocks inside the repeat block.\n\n> Create this programme\n\n\n--- Slide 31 ---\n\nBlock Code\n\nUsing a For Loop try and make an led light move across the entire display from left to right, top row to bottom row.\n\n> Challenge\n\n\n--- Slide 32 ---\n\nRadio in the micro:bit\n\nThe micro:bit allows you to communicate with other micro:bits in the area using the blocks in the Radio category. You can send a number, a string (a word or series of characters) or a string/number combination in a radio packet via a Bluetooth radio. You can also give a micro:bit instructions on what to do when it receives a radio packet.\n\nImage source: makecode.microbit.org\n\n\n--- Slide 33 ---\n\nRadio in the micro:bit (Contd)\n\nWatch this video to see how the radio hardware works on the micro:bit.\n\nVideo source: makecode.microbit.org\n\n\n--- Slide 34 ---\n\nBlock Code\n\nFrom the Radio menu, drag a ‘radio set group’ block to the coding workspace and place the block into the on start block.\n\nIn the ‘radio set group block’, leave the default value of 1 for the group ID.\n\n> Create this programme\n\n\n--- Slide 35 ---\n\nBlock Code\n\nDrag 2 ‘on button pressed’ blocks to the coding workspace. Leave one with the default value A and change the other button to B.\nFrom the Radio Toolbox drawer, drag 2 ‘radio send string’ blocks to the coding workspace. Place one into the ‘on button A pressed’ block, and the other into the ‘on button B pressed’ block.\nIn the ‘on button A pressed’ block, change the default empty string value of the ‘radio send string’ block to the string “Marco”.\nIn the ‘on button B pressed’ block, change the default empty string value of the ‘radio send string’ block to the string “Polo”.\n\n> Create this programme\n\n\n--- Slide 36 ---\n\nBlock Code\n\nTo display the data sent between the micro:bits, drag an ‘on radio received receivedString’ block to the coding workspace.\nFrom the Basic Toolbox drawer, drag a ‘show string’ block into the ‘on radio received receivedString’ block.\nFrom the ‘on radio received receivedString’ block, drag the ‘receivedString’ variable block into the default string value of “Hello” in the ‘show string’ block.\n\n> Create this programme\n\n\n--- Slide 37 ---\n\nBlock Code\n\nAdd a ‘show leds’ block to the ‘on start’ block. (We created an image of the initials MP.)\nFrom the Music Toolbox drawer, drag 2 ‘play tone’ blocks to the coding workspace. \nDrag one of the ‘play tone’ blocks to the ‘on button A pressed’ block, and the other one to the ‘on button B pressed’ block.\nChange the default value in the ‘play tone’ block that is inside the ‘on button A pressed’ block to the value Low C.\n\n> Challenge\n\nImage source: makecode.microbit.org\n\nHow to connect headphones to your micro:bit",
          "file": "Notes/3 - Computers Transforming Society.pptx"
        },
        {
          "id": "26",
          "title": "Brief History of Computing",
          "content": "--- Slide 1 ---\nBrief History of Computing\nLeaving Cert Computer Science\n\n--- Slide 2 ---\nLearning Intentions\nIdentify important computer developments that have taken place in the last 100 years\nConsider emerging trends that could shape future computing technologies\n\n--- Slide 3 ---\nExcellent website for this topic\nhttps://www.livescience.com/20718-computer-history.html\n\n--- Slide 4 ---\nLearning Intentions – 1st November\nIdentify important computer developments that have taken place in the last 100 years\nConsider emerging trends that could shape future computing technologies\n\n--- Slide 5 ---\nWhat is a computer?\nA computer is a general-purpose machine that can take in data(input), processes the data using a set of arithmetic or logical operations (program) and produces a result (output).\n\n--- Slide 6 ---\nA General purpose machine\nThis means the device can carry out wide range of tasks, not just follow a limited set of instructions to achieve a specific purpose e.g desk calculator\nA desk calculator not a computer as it can only carry out a small set of mathematical calculations.\n\n--- Slide 7 ---\nTodays Computers\nThey are programmable, and general purpose but such machines are a very specific type of computer. They are also digital, electronic computers\n\n--- Slide 8 ---\nDigital and Analogue signals (video)\nhttps://www.khanacademy.org/science/ms-physics/x1baed5db7c1bb50b:waves/x1baed5db7c1bb50b:digital-signals/v/digital-and-analog-information\n\n--- Slide 9 ---\nDigital computer\nA signal is a representation of changing information. They are used to transmit information from place to place.\nA digital computer operates using digital signals. These are discrete representations of information i.e. they can only have a limited number of values, in the below case 0 or 1\n\n--- Slide 10 ---\nDigital computer\nInformation can also be transmitted using an analogue signal. In analog signals, the value changes continuously with time. The signal can have an infinite number of values\n\n--- Slide 11 ---\nTHe first Computers\nThe first computers were people.\nAs early as 17th century, the term computer was used to describe a person who performed mathematical calculations for different reasons:\nCompiling maths tables such as logarithms or trigonmetric values\nCalculating movements of celestial bodies such as planets, stars, moons etc\nWorking out the trajectories of missiles for armies\n\n--- Slide 12 ---\nEarly computing machines\nTHE SLIDE RULE\nEarly 1600’s, a mechanical analog computing device called a slide rule was invented\nThey were continually improved until they could calculate \nLogarithms\nTrigonometric functions\nSquares, cubes and their roots\nWidely used up to1970s when they                                           were replaced by the electronic calculator\n\n--- Slide 13 ---\nCharles Babbage – The Father of the computer\n\n--- Slide 14 ---\nCharles Babbage – The Father of the computer\n\n--- Slide 15 ---\nCharles Babbage – The Analytical Engine\nThe Analytical Enginewas invented by Babbage around 1830\nDesigned to carry out general purpose computation on data stored on punched cards\nThe computation was specified by programs stored on punched cards. The designs for the Analytical Engine included mechanical memory and a Central Processing Unit (CPU) to carry out the programmed instructions \nThe Analytical Engine never competed due to lack of funds\nIn todays terminology, the machine was programmable and general purpose and arguably the FIRST (NON_HUMAN) COMPUTER\nhttps://www.youtube.com/watch?v=dWDQdwlK1GM\n\n--- Slide 16 ---\nAda lovelace – the first computer  programmer\nLondon-born Ada Lovelace (1815–1852) is credited with being the world's first computer programmer, as she drafted plans for how a machine called the Analytical Engine could perform computations.\n\n--- Slide 17 ---\nThe early 20th Century.\nMany types of computers invented using mechanical, hydraulic and pneumatic means\nAll very complex, large and heavy making them very expensive and difficult to produce in large numbers\n\n--- Slide 18 ---\nAlan Turing and the Turing Machine\nAlan Turing was one of the first computer scientists\nIn 1936, Alan Turing described a Mathematical Model of computation called the automatic machine (a-machine). This later became known as the Turing machine\nThe Turing Test – The Turing Test is a method of inquiry in artificial intelligence (AI) for determining whether or not a computer is capable of thinking like a human being\nhttps://www.youtube.com/watch?v=4VROUIAF2Do\n\n--- Slide 19 ---\nAlan Turing and the Turing Machine\nAlan Turing was one of the first computer scientists\nIn 1936, Alan Turing described a Mathematical Model of computation called the automatic machine (a-machine). This later became known as the Turing machine\nThe Turing machine is a simple theoretical “machine” that showed the true power of computing before modern computers actually existed.\n\n--- Slide 20 ---\nthe Turing Machine consists of 4 parts\nA tape that symbols can be written to and read from\nA head that does the reading and writing\nA state register that stores the state of the machine any point in time\nA table of instructions to tell the machine what to do next, depending on the current state and the symbol being read at the time e.g. write or erase symbol, move the head\n\n--- Slide 21 ---\nTuring Machine – why are they important?\nTurning machines provide a simple way to model general and powerful computational concepts and programs. This allowed modern computers to be theoretically studied before they physically existed\nVideo on turing machines\nLC219ALP038EV.pdf ( examinations.ie)\n\n--- Slide 22 ---\nElectromechanical Computers\n1940’s – electromechanical computers developed. They had electrical switches to move mechanical parts. \n1941 - The electromechanical Z3 was the first digital programmable computer to be built. The Z3 used binary numbers, high voltage represented a 1, low voltage represented a 0.\nThe use of binary reduced complexity compared to the decimal numbers used in Babbage’s Difference and Analytical Machines.\nhttps://www.youtube.com/watch?v=3WNFBjoJbBA\n\n--- Slide 23 ---\nImpact of the second World War\nThere was increased spending on computers and related devices by government and military during WW2\nCode breaking was a critical challenge for the allies during WW2\nA top secret operation was set up by the allies in Bletchley Park to address code breaking\n\n--- Slide 24 ---\nImpact of the second World War\nAlan Turing was a key figure at Bletchley Park. They used electromechanical devices called Bombes to crack codes created by the German Enigma machines (also electromechanical machines). This codebreaking helped shorten the war by several years\nThe Enigma machines and Bombes were designed for a specific purpose so are NOT general purpose computers. However they advanced many of the technologies needed to jump-start the era of the modern computer.\n\n--- Slide 25 ---\nImpact of the second World War\nVideo on breaking the Enigma code\n\n--- Slide 26 ---\nVacuum Tubes – \nThe start of the electronic computer\n1st generation of computers\nVacuum tubes are electronic devices that control the flow of electricity. They looked somewhat like a light bulb and similar in size. \nVacuum tubes are a glass tube device, which has had its gas removed, creating a vacuum space. It is comprised of electrodes that are designed to control electron flow between the electrodes sealed inside the vacuum tubes.\n\n--- Slide 27 ---\nVacuum Tubes and Electronic Computers\nThe development of the vacuum tubes led to rapid growth of electronic devices such as radio television and computers based on vacuum tube technology.\nThe relatively small size of these devices based on vacuum tubes and their relatively small cost of production, heralded the start of the modern electronic era\n\n--- Slide 28 ---\nVacuum Tubes and Electronic Computers\nFrom 1940s onward electronic computer technology progressed at a rapid speed. Colossus in Bletchley Park was the first electronic, digital, programmable computer in later years of WW2. It was NOT a general purpose computer as it was designed for codebreaking \nThe first electronic, digital (1 and 0s) , programmable, general purpose computer was the ENIAC\n\n--- Slide 29 ---\nVacuum Tubes and Electronic Computers\nThe ENIAC was programmed by plugging and unplugging cables and controlling various switches. They could not store computer programs in their own memory. An Irishwoman Kay McNulty was one of the first programmers of ENIAC https://www.youtube.com/watch?v=k4oGI_dNaPc\n\nThese machines, all-electronic and based on vacuum tubes are known as the First Generation of Computers\nVideo on Vacuum Tube Computers\n\n--- Slide 30 ---\nTransistors\nThe 2nd generation of computers\nTransistors replaced the Vacuum tubes and this revolutionised electronics.\nTransistors are very small electronic switches. They performed the same tasks as the Vacuum tubes but were smaller and more reliable, easier to mass produce, cost and energy efficient.\n\n--- Slide 31 ---\nTransistors\nTransistors were developed over many years mainly at the Bell Laboratory in New Jersey, USA. By late 1950’s transistor technology was so advanced that it rapidly changed the electronics industry, leading to 2nd Generation of Computers based on transistors instead of vacuum tubes\n\n--- Slide 32 ---\nTransistors\nThe IBM 608 is considered the 1st fully transistorised computer that was available commercially. It performed 4,500 operations per second and cost over €500,000 in todays money\nTransistors allowed for the development of “supercomputers” that could perform operation much faster than commonly available computers\n\n--- Slide 33 ---\nTransistors\nThe Control Data Corporation (CDC) 6600 (1964) is considered the 1st commercially viable supercomputer. It could perform 3 million operations per second and cost approx. €20 million in todays money.\nVideo about 2nd generation computers\n\n--- Slide 34 ---\nIntegrated Circuits – \n3rd generation of computers\n3rd generation of computers came around 1960s and were based on integrated circuits\nAn integrated circuit is a collection of electronic components (resistors, transistors, capacitors, etc.) all stuffed into a tiny chip, and connected together to achieve a common goal.\n\n--- Slide 35 ---\nIntegrated Circuits\nOne of the most famous 3rd Generation computers is Apollo Guidance Computer (AGC) (1966) designed by Massachusetts Institute of Technology (MIT).\nMargaret Hamilton designed the software for the AGC. Without this software, the Apollo program, which included landing the 1st people on the moon, would not have been possible\nThe AGC was designed to be small, around 32kg, and very robust because of the conditions it would work in.\n\n--- Slide 36 ---\nMargaret Hamilton Takes Humans to the Moon\nMargaret Hamilton, born in 1936, is an American computer scientist and systems engineer from Indiana who led the Software Engineering Division of the MIT Instrumentation Laboratory. NASA credits her with coining the term “software engineering.” Hamilton worked on software development for Apollo 11, the first spacecraft to complete a successful mission that placed humans on the moon in 1969. Hamilton's insistence on thorough testing is credited with the mission's success and safety of its astronauts.\n\n--- Slide 37 ---\nIntegrated Circuits\nIn 1960’s and 1970’s, the 3rd generation of computers allowed the development of “minicomputers” which were small enough to move between different locations easily.\nThe integrated chip allowed computers to become much more powerful quickly. In 1970’s Cray Research, developed its own supercomputer, the Cray-. This started the modern era of supercomputing, which continues to drive many scientific discoveries.\nVideo on 3rd Generation Computers\n\n--- Slide 38 ---\nMicroprocessors\nThe 4th generation of computers is based on microprocessors. Most of todays computers are of this generation.\nA microprocessor is a device used as the main brain of a computer system. A microprocessor is what we now call CPU, central processing unit.\nCPU takes in binary data, performs operations on that data from instructions stored in its memory and the proves the result as output.\n\n--- Slide 39 ---\nMicroprocessors\nIntel 4004 (1971) was the first microprocessor developed\nTodays microprocessors contain billions of transistors on a single chip, less than the size of your palm. This allows personal computers to become practical and affordable in the late 1970’s / early 1980’s. This had led to computers everywhere in our lives today\n\n--- Slide 40 ---\nPersonal computers\n1975 - The 1st personal computers included models from Commodore, Apple, IBM. \nThese PCs had to be usable by non-experts. This led to the creation of operating systems and user-friendly interfaces such as Microsoft Windows (founded 1975) and hardware devices such as mice, keyboards and displays that we are familiar with today.\n\n--- Slide 41 ---\nModern computers\nModern computers include laptops, PCs, tablets, mobile phones as they are all digital, electronic, programmable and are multi purpose.\nPCs costing a few hundred euros now have memory capacities and chips that operate at speeds that would have cost millions in the 1980s.\n\n--- Slide 42 ---\nModern computers\n\n--- Slide 43 ---\nThe fastest computers - No 1\nFrontier was built in 2022 by Hewlett Packard Enterprise in collaboration with its subsidiary Cray. \nFrontier has a total of 8,730,112 cores. Each of its 74 computing cabinets weigh about 3650 kg and the entire system costs a whopping $600 million in total.\nhttps://www.youtube.com/watch?v=etVzy1z_Ptg\n\n--- Slide 44 ---\nMoore’s Law\nThe first Intel microprocessor (CPU), Intel 4004 (1972), had 2,300 transistors\nNowadays, a microprocessor (on a single chip) has billions of transistors. For instance an Xbox One has 5 billion.\n In 1965 Gordon Moore states that the number of transistors on a microchip doubles every two years. The law claims that we can expect the speed and capability of our computers to increase every two years because of this, yet we will pay less for them. This is known as Moore’s Law.\n\n--- Slide 45 ---\n(no extractable text)\n\n--- Slide 46 ---\nMoore’s Law\nExperts agree that computers should reach the physical limits of Moore's Law at some point in the 2020s. One reason is:\ntransistors will be unable to operate within smaller circuits at increasingly higher temperatures. This is due to the fact that cooling the transistors will require more energy than the energy that passes through the transistor itself. \n\nhttps://www.youtube.com/watch?v=1qQE5Xwe7fs\n\n--- Slide 47 ---\nThe Next Generation of computers\nThis is difficult to predict due to rapid pace of development.\nPossibly Quantum Computers based on quantum mechanical principles. \nQuantum Computer prototypes exist but many barriers to overcome before they become viable. They are very sensitive to heat so must be kept at ultra cold temperature -273 celcius\n\n--- Slide 48 ---\nGrace Hopper Pioneers Computer Programming\nAmerican Grace Hopper (1906–1992) was an admiral in the United States Navy and a computer scientist who was one of the first programmers for the Harvard Mark I computer, which was a general purposes electromechanical computer used in the war effort for World War II.\n1953: Grace Hopper develops the first computer language, which eventually becomes known as COBOL,\n\n--- Slide 49 ---\nKatherine Johnson Executes Critical Space Calculations\nKatherine Johnson, born in 1918, is one of the women immortalized in the 2016 book and movie Hidden Figures. A West Virginia native and American mathematician, Johnson helped confirm the accuracy of electronic computers used by NASA and performed critical calculations that ensured safe space travel from the 1950s on. She coauthored a research report that used equations for orbital spaceflight in 1960, performed trajectory analysis for the first human space flight in 1961, and ran equations on a desktop mechanical calculating machine before the 1962 orbital mission of John Glenn. \nIn 2015, she received the Presidential Medal of Freedom.\n\n--- Slide 50 ---\nFemale pioneers in computer science\nhttps://www.youtube.com/watch?v=_ZjGOiJXVBA",
          "file": "Notes/26 - Brief History of Computing.pptx"
        }
      ]
    },
    {
      "title": "Hardware & Systems",
      "notes": [
        {
          "id": "5",
          "title": "Computer Systems",
          "content": "--- Slide 1 ---\n\nComputer Systems\n\nOct 2023\n\n\n--- Slide 2 ---\n\nWhat will I learn today 9/3/2022\n\n\n--- Slide 3 ---\n\nWhat is a computer system?\n\nComputer systems are a combination of both hardware and software working together to achieve a common goal.\n\nA computer system can be described as one that involves interaction between:\nHardware (physical computer, screen, mouse, keyboard etc)\nSoftware (the computer programs e.g. operating system,  Microsoft Word, Google Chrome..)\nData\nThe human user\n\n\n--- Slide 4 ---\n\nHow Computers Work Introduction\n\nHow Computers Work: What Makes a Computer, a Computer? - YouTube\n\n\n--- Slide 5 ---\n\nComputer Architecture\n\nComputer Architecture is a specification of how a computer’s parts are physically and logically connected.\nComputer Architecture is similar to architecture of a house, there are many different designs\nMany of today’s computers have a common high-level architecture, that is known as Von Neumann  Architecture\n\n\n--- Slide 6 ---\n\nVon Neumann  Architecture Introduction\n\nVery early computers could not store programs and, hence, in 1945, John von Neumann developed an idea of a computer that could store programs, which is also known as von Neumann architecture.\nHe suggested that data and programs could be stored in memory and that the data would be transferred between the memory and the processor during processing. \nThe computer architecture he described in 1945 is still relevant today\n\n\n--- Slide 7 ---\n\nCPU and Von Nuemann Architecture\n\nhttps://www.youtube.com/watch?v=SbqXqQ-2ixs\n\n\n--- Slide 8 ---\n\nvon Neumann Architecture\n\nVon Neumann architecture contains four main components:\nA Central Processing Unit (CPU) which executes instructions\nMemory which stores both DATA to be operated on, the INSTRUCTIONS (programs) that operate on the data, and the results.\nA Bus connecting the CPU and the memory. This is represented by the pair of arrows (from memory to CPU and back)\nInput and Output devices that allow data to come into the computer and results to be sent out.\nAll the components work together to allow processing of the data and system control.\n\n\n--- Slide 9 ---\n\nVon Nuemann Architecture\n\n\n--- Slide 10 ---\n\nVon Neumann Architecture  - CPU\n\nThe Control unit (CU) directs/controls the operation of the CPU.\nThe control unit is responsible for controlling the memory, processor and input-output devices. \nIt contains the CIR (Current Instruction Register) and PC (Program Counter) registers. \nThe CIR (register) contains the current instruction carried out by the processor. \nThe PC contains the location of the next instruction to be executed. \nThe control unit reads the instructions from the memory, decodes it and sends control signals to the memory and input-output devices.\n\n\n--- Slide 11 ---\n\nVon Neumann Architecture\u000b - CPU\n\nArithmetic logic unit (ALU)\nThe ALU has two main functions:\nThe ALU is responsible for arithmetic functions such as addition, subtraction, multiplication, etc. and logic operations such as AND, OR, NOT, etc. \nThe accumulator register (ACC) stores the results of arithmetic and logical operations performed by a processor.\n\n\n--- Slide 12 ---\n\nVon Neumann Architecture\u000b - CPU\n\nRegisters\nRegister memory is very expensive and the fastest. Registers have a small capacity compared to other types of memory e.g. RAM or ROM\nDifferent processors have different numbers of registers for different purposes. Most have some, or all, of the following:\nprogram counter (PC)\nmemory address register (MAR)\nmemory data register (MDR)\ncurrent instruction register (CIR)\naccumulator (ACC)\n\n\n--- Slide 13 ---\n\nVon Neumann Architecture\u000b - CPU\n\nRegisters\nRegisters -> The Program Counter\nContains the memory location of the next instruction to be executed\nCIR (Current Instruction Register) the current instruction being decoded\nAccumulator (ACC) - the results of calculations\n\n\n--- Slide 14 ---\n\nVon Neumann Architecture - CPU\n\nRegisters -> Memory Data Registers\nHold data temporarily. This data is operated on by the CPU. This data originally came from memory across the bus and the results will typically be returned to memory.\nRegisters -> Memory Address Registers\nStore memory addresses. This is a value that indicates a specific location in memory. This could be the location in memory of data to be operated on, or results to be sent to memory over the bus.\n\n\n--- Slide 15 ---\n\nVon Nuemann Architure – Input & Output Devices\n\nAn input device, like a keyboard or mouse, converts the signals sent by humans to a form that can be understood by the computer. \nOutput devices such as printers, monitors, etc. convert the information from the computer into a form that is understandable by humans.\n\n\n--- Slide 16 ---\n\nVon Neumann Architecture – \u000bFetch –Decode- Execute Cycle\n\nTo carry out the instructions, the processor fetches the data and instructions from the memory and stores it in suitable registers. \nThese instructions are decoded and then executed.\n\n\n--- Slide 17 ---\n\nThe Fetch – Execute Cycle\n\n\n--- Slide 18 ---\n\nThe fetch-decode-execute cycle: Fetch\n\nThe program counter contains the location of the instruction that is to be executed next. This address is copied to the MAR. \nThe instruction is fetched from the memory and copied to the MDR first. \nThen, contents of the MDR are copied to the CIR (Current Instruction Register). \nThe value in a program counter is incremented by 1 and, hence, the instruction in the next memory location is processed.\n\n\n--- Slide 19 ---\n\nThe fetch-decode-execute cycle: Decode and execute\n\nDecode\nThe instructions in the CIR are decoded so that it can be executed.\nExecute\nThe processor sends appropriate control signals to the memory unit and input-output devices in the computer system, according to the decoded instruction.\n\n\n--- Slide 20 ---\n\nRegisters involved in the Fetch –Decode – Execute Cycle\n\n\n--- Slide 21 ---\n\nVon Neumann Architecture -> The Bus\n\nA bus is a communication pathway that allows data and instructions to travel between different components in a computer. Think of it as a collection of wires that allow data and instructions to move from memory to the CPU and back.\nThere are many buses on the motherboard. The speed of a bus is measured in megahertz (MHz). The faster the bus, the faster data is communicated. The speed of the motherboard is defined by the bus speed.\nBuses are limited by their width in bits. They are usually 8, 16 or 32-bits wide. This tells us how many bits can be sent by the bus at any one time, eg a 32-bit bus can send 32 bits at once.\n\n\n--- Slide 22 ---\n\nvon Neumann architecture The Buses\n\n22\n\n\n--- Slide 23 ---\n\nBuses\n\n23\n\n\n--- Slide 24 ---\n\nLet’s review some concepts\n\nBuses\nThe connection between the processor, memory, and input-output devices.\n\nProcessor\nThe processor contains ALU (Arithmetic and Logic unit) and Control Unit (CU).\n\nCIR (Current Instruction register)\nThe CIR contains the current instruction carried out by the processor\n\nPC (Program Counter)\nThe PC contains the location of the instruction that is to be executed next.\n\nAccumulator \nAccumulator (ACC) is the register that stores the results of arithmetic and logical operations performed by the processor.\n\n\n--- Slide 25 ---\n\nVon Neumann Architecture - Memory\n\nEarly computers could not store programs internally. Programs had to be stored externally on punch cards, magnetic tapes or floppy disks.\nModern computers store programs internally in memory.\n\n\n--- Slide 26 ---\n\nPrimary Memory - RAM\n\nRAM is PRIMARY Memory\nRandom Access Memory (RAM) is known as volatile memory. If the computer loses power, the data in RAM is lost. RAM is fast compared to other memory that is not volatile.\nRAM holds the data and instructions of the program that is currently being executed by the CPU. \nRAM is not where files are stored for long-term use, e.g photos on your computer. They are stored in secondary memory.\n\n\n--- Slide 27 ---\n\nPrimary Memory - ROM\n\nROM read only memory is non-volatile. Its contents remain stored whether the computer is powered on or not. A typical use of ROM is to store the computer’s BIOS (Basic input/output system) which is the software responsible for booting up the system. When computer is turned on, BIOS performs the necessary checks and then hands control over to the operating system\n\n\n--- Slide 28 ---\n\nMemory\n\nMemory used to store information for immediate use by the CPU is also referred to as main memory or primary storage. RAM and ROM are both types of primary storage\nHow computer memory works\nBBC Bitesize Revision - CPU & Memory\n\n\n--- Slide 29 ---\n\nSystem Archtecture - CPU\n\nCache\nCache is a small amount of high-speed random access memory (RAM) built directly within the processor. It is used to temporarily hold data and instructions that the processor is likely to reuse. This allows for faster processing, as the processor does not have to wait for the data and instructions to be fetched from the RAM.\n\n\n--- Slide 30 ---\n\nFactors Determining the Speed of the CPU\n\nEven though today's processors are tremendously fast, their performance can be affected by a number of factors including:\n\nclock speed\nNumber of cores\n- Cache size\n- RAM\n\n\n--- Slide 31 ---\n\nFactors Determining the Speed of the CPU\n\nNumber of cores. A processing unit within a CPU is known as a core. Each core is capable of fetching, decoding and executing its own instructions. The more cores a CPU has, the greater the number of instructions it can process in a given space of time.\n\n\n--- Slide 32 ---\n\nFactors Determining the Speed of the CPU\n\nClock speed. Clock speed is the number of pulses the CPU’s clock generates per second. It is measured in hertz. The more pulses per second, the more fetch-decode-execute cycles that can be performed and the more instructions that are processed in a given space of time.\n\n\n--- Slide 33 ---\n\nFactors Determining the Speed of the CPU\n\nCache. A cache is a fast, relatively small capacity set of locations that is built directly within the processor. Cache is used to store the instructions and data that the processor is most likely to need and reuse. The bigger its cache, the less time a processor has to wait for instructions to be fetched. \n\n\n--- Slide 34 ---\n\nFactors Determining the Speed of the CPU\n\nRAM. This is the short-term memory of the computer that holds all of the programs and data currently being ran by the computer. Having more memory means that the data and instructions that need to be processed will not have to be fetched from secondary storage (which is a much slower process). \nTemperature. If CPU gets too hot performance will decrease.\n\n\n--- Slide 35 ---\n\nFactors affecting the speed of a CPU\n\nhttps://www.youtube.com/watch?v=eS1rEJZKr4U\n\n\n--- Slide 36 ---\n\nVon Neumann Architecture -> Secondary Storage\n\nSecondary devices are used to store data persistently.  They store information regardless of whether the computer is turned on or not. It is non-volatile memory, unlike RAM that is volatile.\n\n\n--- Slide 37 ---\n\nDifferences between Primary and Secondary storage\n\nPrimary storage stores information for immediate use by the CPU while secondary storage stores data that can be used at any time.\nPrimary storage stores data temporarily (apart from ROM), whereas secondary storage stores data persistently\nPrimary storage is faster than secondary storage\n\n\n--- Slide 38 ---\n\nDifferences between Primary and Secondary storage\n\nPrimary storage is more expensive than secondary storage per unit, such as megabyte(MB) or gigabyte (GB).\nPrimary storage is smaller ( less capacity)\n\n\n--- Slide 39 ---\n\nSecondary storage\n\nA typical modern personal computer can store up to several terabytes (TB). RAM is in the order of several or several dozen gigabytes (GB)\nSecondary storage are normally hard drives. There are 2 types of hard drives magnetic and solid state disk (SSD). Magnetic hard drives are more common.\nMagnetic hard disks contain a magnetic platter that turns at a very high speed. A head moves across the spinning platter and reads information\n\n\n--- Slide 40 ---\n\nSecondary storage\n\nSolid State Disks (SSD) is becoming more widespread. These are faster and more durable than magnetic disks because they have no moving parts. Most SSD are based on flash memory. Flash memory is what USB memory stick are based on.\nSSD are expensive but the price is falling\n\n\n--- Slide 41 ---\n\n\n--- Slide 42 ---\n\nSpeed & Cost of Memory\n\n\n--- Slide 43 ---\n\nThe closer a memory type is to the CPU, the quicker the CPU can access the instructions and execute them. However, the closer it is to the CPU the smaller and more expensive it is. Each type of memory is limited by their speed, size, cost and position in relation to the CPU.\n\nMemory Overview\n\n\n--- Slide 44 ---\n\nThe Motherboard\n\nBBC Bitesize Revision Motherboard\nThe motherboard is a circuit board that devices are physically mounted on.\nIt connects the CPU to the memory and all the other hardware. The CPU sits on the motherboard\nMotherboard’s typically include: CPU, main memory, hard drive and many other components such as I/O devices.\nWhen you plug in a USB device into a computer, you are physically connecting to the mother board\n\n\n--- Slide 45 ---\n\nOperating Systems\n\nAn operating system (or 'OS') controls the general operation of a computer, and provides an easy way for us to interact with computers and run applications.\n\nThe OS runs runs all the time in the background\nEvery computer has an OS. They could not run without it.\n\n\n--- Slide 46 ---\n\nOperating Systems\n\nThere are a few common operating systems available:\nMac OS X - operating system for Macs\nLinux, Ubuntu, Unix  – based on Unix\nWindows\nAndroid (based on Linux)\nApple iOS\n\n\n--- Slide 47 ---\n\nFunctions of the Operating Systems\n\nThe operating system performs several key functions:\ninterface - provides a user interface so it is easy to interact with the computer, known as “user interface”\nmanages the CPU - runs applications and executes and cancels processes\nmulti-tasks - allows multiple applications to run at the same time\nManages memory - transfers programs into and out of memory, allocates free space between programs, and keeps track of memory usage\n\n\n--- Slide 48 ---\n\nFunctions of the Operating Systems\n\nThe operating system performs several key functions:\n5. \tManages peripherals - opens, closes and writes to peripheral devices such as storage attached to the computer\n6.\t organises - creates a file system to organise files and directories and manages it\n7. \tsecurity - provides security through user accounts and passwords\n8.\tutilities - provides tools for managing and organising hardware\n\n\n--- Slide 49 ---\n\nOperating Systems Functions – User Interface\n\nUser interface\nA user interface is the means by which the user provides input to a computer and the computer conveys output to the user. Specifically, it is the point of interaction between a user and a computer through the use of input / output devices. \nThe UI is either graphical or text-based.\nGraphical user interface (GUI)\nThe OS on most computers and smartphones provides an environment with tiles, icons and/or menus. This type of interface is called the graphical user interface (GUI) because the user interacts with images through a mouse, keyboard or touchscreen.\n\n\n--- Slide 50 ---\n\nOperating Systems – User Interface\n\nCommand line interface (CLI)\nAn OS also provides a method of interaction that is non-graphical, called the command line interface (CLI). This is a text-only service with feedback from the OS appearing in text. Using a CLI requires knowledge of the commands available on a particular machine.\nAdvantages of using the command line include:\na faster way to get tasks done\nit is more flexible than a GUI\nit uses less memory\nSome games, such as Minecraft, also make use of a command line tool which allows the user to bypass the main interface and alter the game’s mechanics or environment.\n\n\n--- Slide 51 ---\n\nOperating Systems – User Interface\n\n\n--- Slide 52 ---\n\n2023 LC Higher Level Q4",
          "file": "Notes/5 - Computer Systems.pptx"
        },
        {
          "id": "16",
          "title": "The Number Systems",
          "content": "--- Slide 1 ---\n\nThe Number System\n\nBasics of computing\n\n\n--- Slide 2 ---\n\nLearning Intention\n\nAt the end of the class, students will\nUnderstand why computers use binary to represent data\nRecognize our normal number system as the decimal or base 10\nDefine the different units of data storage\nConvert numbers from binary to decimal\n\n\n--- Slide 3 ---\n\nDigital Computer\n\nIn everyday life, we use numbers based on combinations of the digits between 0 and 9. This counting system is known as decimal or base 10.\nTry this with 83678\nAnd 98438\n\n\n--- Slide 4 ---\n\nDigital Computer\n\nComputers use 1s and 0s to represent the flow of electricity\n\t1 is used to show the electricity is flowing, and 0 shows that it is not flowing.\nAll data we want to the computer to process must be converted into binary code (1s an 0s)\nEach 1 or 0 in a binary code is a bit (binary digit). For example 1010 is 4 bits.\n\n\n--- Slide 5 ---\n\nDigital Computer Transistors\n\nThe circuits in a computer's processor are made up of billions of transistors. A transistor is a tiny switch that is activated by the electronic signals it receives. The digits 1 and 0 used in binary reflect the on and off states of a transistor.\n\n\n--- Slide 6 ---\n\nLeaving Cert Questions\n\n\n--- Slide 7 ---\n\nSizes of other units of data\n\n\n--- Slide 8 ---\n\nSizes of other units of data\n\nDifferent types of data require different amounts of storage space. Some examples of this follow\n\n\n--- Slide 9 ---\n\nData  Representation\n\n\n--- Slide 10 ---\n\nLeaving Cert Questions\n\n\n--- Slide 11 ---\n\nLeaving Cert Questions\n\n\n--- Slide 12 ---\n\nLeaving Cert Questions\n\n\n--- Slide 13 ---\n\nLeaving Cert Questions\n\n\n--- Slide 14 ---\n\nConverting from binary to decimal\n\n\n--- Slide 15 ---\n\nConvert from binary to decimal\n\n\n--- Slide 16 ---\n\nLeaving Cert Questions\n\n\n--- Slide 17 ---\n\nLeaving Cert Questions\n\n\n--- Slide 18 ---\n\nConvert from decimal to binary\n\nStep 1: Divide the given decimal number by 2 and note down the remainder.\nStep 2: Now, divide the obtained quotient by 2, and note the remainder again.\nStep 3: Repeat the above steps until you get 0 as the quotient.\nStep 4: Now, write the remainders in such a way that the last remainder is written first, followed by the rest in the reverse order.\n\n\n--- Slide 19 ---\n\nConvert from decimal to binary\n\nExample: Convert the decimal number 13 to binary.\n\nSolution: We will start dividing the given number (13) repeatedly by 2 until we get the quotient as 0. We will note the remainders in order.\n\n\n--- Slide 20 ---\n\nConvert from decimal to binary\n\nExample: Convert the decimal number 123 to binary.\n\nSolution: We will start dividing the given number (123) repeatedly by 2 until we get the quotient as 0. We will note the remainders in order.\n\nVideo on converting decimal to binary\n\n\n--- Slide 21 ---\n\nPractice time – \u000bConvert the following decimal numbers to binary\n\n67\n92\n110\n59\n\n\n--- Slide 22 ---\n\nBinary Addition\n\n\n--- Slide 23 ---\n\nBinary Addition\n\nVideo binary Addition\n\n\n--- Slide 24 ---\n\nPractice time – \u000bAdd the following binary numbers\n\n1101 + 1010\n1110001 + 10001\n11010 + 110011\n\n\n--- Slide 25 ---\n\nLeaving Cert Questions\n\n\n--- Slide 26 ---\n\nOverflow Errors –\n\nSometimes, during binary arithmetic you will get a result that requires MORE bits than the CPU is expecting – this is called OVERFLOW.\nE.g. the 8 bit calculation 11111111 + 00000001 gives the 9-bit answer 100000000. Computers will see the 1 as an overflow error and just output 00000000 as the result, which is nonsense.\n\n\n--- Slide 27 ---\n\nOverflow Errors –\n\nComputers usually deal with these extra bits by storing them elsewhere. Overflow flags are used to show an overflow error has occurred\nOverflow errors lead to a loss of data and a loss of accuracy in your answer. It can also cause software to crash if it doesn’t have a way of dealing with the extra bit.\n\n\n--- Slide 28 ---\n\nBinary Shift –\n\nA binary shift moves every bit in a binary number to the left or right a certain number of places\nGaps at the beginning or end are filled in with 0s\nThe direction of the binary shift indicates whether it multiplies or divides the binary number.\n\n\n--- Slide 29 ---\n\nBinary Shift –\n\n\n--- Slide 30 ---\n\nExample of Binary Shifts –\n\n\n--- Slide 31 ---\n\nExample of Binary Shifts –\n\n\n--- Slide 32 ---\n\nHexadecimal code\n\nHexadecimal code or “Hex” are base 16 numbers\nWe use 0-9 for the 1st 10 digits and then A-F as the symbols for the other 6. All hexadecimal numbers are made of a combination of these digits.\n\n\n--- Slide 33 ---\n\nHexadecimal code\n\nHexadecimal or base 16 uses 16 different digits\nA single hex character can represent any decimal number from 0 – 15\nTo represent 0 – 15 in binary requires 4 bits (nibble), so each hex character equates to a 4 bits in binary\nProgrammers prefer hex when coding \n\tbecause – its simpler to remember large\n\tnumbers in hex (they’re shorter)\n\t- It’s easier to convert between binary \n\tand hex than binary and decimal.\n\n\n--- Slide 34 ---\n\nConverting from Hexadecimal to Decimal code\n\n\n--- Slide 35 ---\n\nConverting from Decimal to Hexadecimal\n\nSimilar to method for converting decimal to binary.\nStep 1: Divide the given decimal number by 16 and note down the remainder.\nStep 2: Now, divide the obtained quotient by 16, and note the remainder again.\nStep 3: Repeat the above steps until you get 0 as the quotient.\nStep 4: Now, write the remainders in such a way that the last remainder is written first, followed by the rest in the reverse order.\n\n\n--- Slide 36 ---\n\nConverting from Decimal to Hexadecimal\n\n\n--- Slide 37 ---\n\nConverting from Hex to binary\n\nHex is very easy to convert to binary.\nWrite down the hex number and represent each hex digit by its binary equivalent number from the table above.\nUse 4 digits and add insignificant leading zeros if the binary number has less than 4 digits. E.g. Write 102 (2 decimal) as 00102.\nThen concatenate or string all the digits together.\nDiscard any leading zeros at the left of the binary number.\n\n\n--- Slide 38 ---\n\nConverting from binary to hex\n\nStart from the least significant bit (LSB) at the right of the binary number and divide it up into groups of 4 bits. \nConvert each group of 4 bits to its equivalent hex value.\nConcatenate the results together, giving the total hex number.\n\n\n--- Slide 39 ---\n\nLeaving Cert Questions\n\n\n--- Slide 40 ---\n\nMore Practice Questions\n\n\n--- Slide 41 ---\n\nMore Practice Questions\n\n\n--- Slide 42 ---\n\nMore Practice Questions\n\n\n--- Slide 43 ---\n\nMore Practice Questions\n\n\n--- Slide 44 ---\n\nMore Practice Questions",
          "file": "Notes/16 - The Number Systems.pptx"
        },
        {
          "id": "17",
          "title": "Electronics & Logic Gates",
          "content": "--- Slide 1 ---\n\nElectronic Components and Logic Gates\n\n5th Yr Computer Science\n\n\n--- Slide 2 ---\n\nBinary Code and electrical signals\n\nModern computers use binary code to represent all information. \nWe represent binary code using symbol pairs, the most common pair is (0,1)\nAll binary system have TWO and only TWO possible values. \nIn a computer, these are physically represented by the presence of or lack of presence of, an electric signal\n\n\n--- Slide 3 ---\n\nBinary Code and electrical signals\n\nThese electrical signal is often referred to as “on” (signal present) and “off” (no signal present).\nThis is a simple concept and one of the fundamental strengths of modern digital, electronic, binary computer, which almost all computers now are.\n\n\n--- Slide 4 ---\n\nBinary Code and electrical signals\n\nAnalogue signals\nMusic and speech vary continuously in frequency and amplitude. In the same way, analogue signals can vary in frequency, amplitude, or both. FM (Frequency Modulated) and AM (Amplitude Modulated) are two types of radio signals. The diagram shows a typical oscilloscope trace of an analogue signal.\n\n\n--- Slide 5 ---\n\nBinary Code and electrical signals\n\nDigital signals\nDigital signals are a series of pulses consisting of two states: ON (1) or OFF (0). There are no values in between. DAB (Digital Audio Broadcast) radio is transmitted as digital signals. The diagram shows a typical oscilloscope trace of a digital signal.\n\n\n--- Slide 6 ---\n\nAnalogue and Digital input/output on Microbits\n\nExample of Analogue sensors on the microbit are \nLight Sensor\nSound Sensor\nExample of Digital input on the microbit are \nButton A, Button B\n\nDigital vs Analogue sensors on microbit\n\n\n--- Slide 7 ---\n\nElectricity and electrons\n\nElectricity\nElectricity is a form of energy arising from the movements of electrons.\nElectrons are negatively charged particles found in every atom.\nThe CPU, memory, bus and all other components are all electronic devices.\nThey work by controlling the flow of electrons through the device.\n\n\n--- Slide 8 ---\n\nElectric Current\n\nCurrent\nElectric current is the flow of electrons from one place to another. The greater the rate of electron flow, the greater the current there is.\n\n\n--- Slide 9 ---\n\nVoltage\n\nVoltage\nAn electron will not move without voltage. Voltage is electrical force that causes electrons to flow. \nVoltage is the measure of the difference in electrical energy between two parts of a circuit. The bigger the difference in energy, the bigger the voltage.\n\n\n--- Slide 10 ---\n\nVoltage\nIn this circuit a voltage exists between each end of the battery. The electrons will flow along the connecting wire, lighting up the bulb i.e. a current flows through the circuit.\nThe current can only flow if there is a complete circuit (no break) from the battery through the wires and back to the battery again\n\n\n--- Slide 11 ---\n\nResistance\n\nResistance\nIs a measure of how much a material resists (or obstructs) the flow of electrons (current).\nDifferent materials have different resistances to the flow of electrons.\nCopper (an electrical conductor) has very low resistance and glass (an electrical insulator) has very high resistance. Gold is an excellent conductor as it has extremely low resistance.\n\n\n--- Slide 12 ---\n\nBasic electronic devices - Resistor\n\nResistors\nA resistor is a device that reduces current flow\nA kettle is like a big resistor. Its difficult for the electricity to flow through the kettle’s element. This creates heat that causes the water to boil.\nResistors have different values. Many resistors have colour bands on them that indicate their resistance value.\n\n\n--- Slide 13 ---\n\nBasic electronic devices - Resistor\n\nResistors\nA kettle is like a big resistor. Its difficult for the electricity to flow through the kettle’s element. This creates heat that causes the water to boil.\nResistors have different values. Many resistors have colour bands on them that indicate their resistance value.\n\n\n--- Slide 14 ---\n\nBasic electronic devices - Transistor\n\nTransistor\nTransistors are tiny electronic switches \nTransistor is an electronic switch within a circuit that allows a small current change to “switch” on or off a larger current\n\n\n--- Slide 15 ---\n\nBasic electronic devices - Capacitor\n\nA capacitor stores electrical energy in the form of electrical charge. Unlike batteries, capacitors do not store electrical energy for long periods of time.\nCapacitors are often used in volatile memory (RAM)\n\n\n--- Slide 16 ---\n\nBasic electronic devices - Capacitor\n\nYou can see a capacitor in action when you turn off certain electronic devices. When you press the power off button, the light that tells you the system is on, stays on for a few seconds, but then dims before going out. This is the capacitor discharging.\n\n\n--- Slide 17 ---\n\nBasic electronic devices - Capacitor\n\nCapacitors also found in touchscreens. When you touch the screen, it changes the amount of charge at that point because your skin is a weak electrical conductor. The change in charge is very small but enough to be detected by the device\nCapacitors are often used in series with resistors to achieve a time delay. The time it takes for the capacitor to become charged is related to the size of the capacitor and the value of the regulating resistor.\n\n\n--- Slide 18 ---\n\nThe CPU and logic gates\n\nBinary code is represented by electrical signals in the computer.\nDifferent devices (resistors, capacitors, transistors etc..) manipulate the flow of these signals in different ways\nIn the CPU, the TRANSISTOR is responsible for manipulating the binary code (strings of 0s and 1s)\nThe transistor acts as a switch. If the transistor is switched to “on” electrical current can flow, represented by 1.\nIf the switch is “off”, the electrical flow stops and is represented by 0.\n\n\n--- Slide 19 ---\n\nThe CPU and logic gates\n\nMany of the instructions that a CPU must carry out are based on Boolean operators, such as and, or , not\nTransistors can be arranged in different ways to carry out Boolean (logic) operations on data. These arrangements of transistors into circuits are known as Logic Gates\nLogic gates allow the CPU to carry out Boolean operations on binary code, by controlling the flow of electricity, represented by 1s and 0s.\n\n\n--- Slide 20 ---\n\nThe CPU and logic gates\n\nA CPU is mainly made up of lots of combinations of logic gates, with each type of gate consisting of a particular circuit of transistors. There are billions of transistors in the CPU.\n\n\n--- Slide 21 ---\n\nLogic Gates –> and gate\n\nThis is a diagram of an and gate, which can be constructed from a few transistors.\nAn and gate, has 2 inputs -> A & B, and one output, Y. \nThe table is called a truth table. It shows the values of Y (output), for all possible combinations of input values A and B, for an and gate.\n\n\n--- Slide 22 ---\n\nLogic Gates –> or gate\n\nThis is a diagram of an or gate, \nAn or gate, has 2 inputs -> A & B, and one output, Y. \nThis is the truth table for an or gate\n\n\n--- Slide 23 ---\n\nLogic Gates –> not gate\n\nThis is a diagram of a not gate, \nA not gate, has 1 inputs -> A, and one output, Y. \nThe output is the inverse (opposite) of the input.\nIf A is 1, the output is 0\nThis is the truth table for a not gate\n\n\n--- Slide 24 ---\n\nLogic Gates –> nand gate\n\nThis is a diagram of an nand gate,\nA nand gate, has 2 inputs -> A & B, and one output, Y. \nA nand gate is the same as an and gate followed by a not gate.\nThis means the output of a nand gate is the opposite of the output of an and gate\n\n\n--- Slide 25 ---\n\nLogic Gates –> nor gate\n\nThis is a diagram of an nor gate,\nA nor gate, has 2 inputs -> A & B, and one output, Y. \nA nor gate is the same as an or gate followed by a not gate.\nThis means the output of a nor gate is the opposite of the output of an or gate\n\n\n--- Slide 26 ---\n\nCombining Logic Gates\n\nLogic gates can be combined to make logic circuits.\nThe logic circuit in this diagram shows the output Q from a not gate being used as one of the inputs to an and gate.\nThis can be written as a Boolean expression :\nP = (not A) and B\n\n\n--- Slide 27 ---\n\nCombining Logic Gates\n\nCalculate the output P, for any combinations of A and B, using a Truth Table\nStep 1:Start with a blank Truth Table and include an intermediate output Q\n\n\n--- Slide 28 ---\n\nCombining Logic Gates\n\nStep 2: Enter all the possible combinations of inputs A and B into the truth table\n\n\n--- Slide 29 ---\n\nCombining Logic Gates\n\nStep 3: Work out the intermediate output Q for each combination of input A to the NOT gate\n\n\n--- Slide 30 ---\n\nCombining Logic Gates\n\nStep 4: Use the input value B and Q, calculate the values of P.    \nP = B AND Q\n\n\n--- Slide 31 ---\n\nLogic Diagrams based on Boolean expressions\n\nLogic diagrams can be drawn based on Boolean expressions.\nLet’s draw :\nY = (A and B) or not C\nStep 1: Working backwards from the output Y, we know that Y results from a combination of 2 inputs to an or gate.\nDraw an or gate with output Y and 2 intermediate inputs P and Q. Leave room on the Lefthand side for other gates.\n\n\n--- Slide 32 ---\n\nLogic Diagrams based on Boolean expressions\n\nLogic diagrams can be drawn based on Boolean expressions.\nLet’s draw :\nY = (A and B) or not C\nStep 1 :\n\n\n--- Slide 33 ---\n\nLogic Diagrams based on Boolean expressions\n\nY = (A and B) or not C\nStep 2: Assuming that P is the output (A and B), draw an and gate with inputs A and B and output P.\nAssuming that Q is the output of (not C), draw a not gate with input C and output Q.\n\n\n--- Slide 34 ---\n\nLogic Diagrams based on Boolean expressions\n\n\n--- Slide 35 ---\n\nLogic Diagrams based on Boolean expressions\n\n\n--- Slide 36 ---\n\nLogic Diagrams based on Boolean expressions\n\n\n--- Slide 37 ---\n\nLogic Diagrams based on Boolean expressions\n\n\n--- Slide 38 ---\n\nLogic Gates / Truth Tables\n\nLogic Gates and truth table introduction\nMaking your own 4 bit computer from transistors",
          "file": "Notes/17 - Electronics & Logic Gates.pptx"
        }
      ]
    },
    {
      "title": "Python Programming",
      "notes": []
    },
    {
      "title": "Problem Solving & Algorithms",
      "notes": [
        {
          "id": "12",
          "title": "Computational Thinking",
          "content": "--- Slide 1 ---\n\nComputational Thinking\n\nChapter 7\n\n\n--- Slide 2 ---\n\nWhat is Computational Thinking\n\nComputational thinking allows us to take a complex problem, understand what the problem is and develop possible solutions.\n The term computational thinking was popularized by Professor Jeannette Wing. Wing defined computational thinking as “the thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information processing agent”\n\n\n--- Slide 3 ---\n\nComputational Thinking\n\nComputational thinking involves four key techniques or “pillars”: \nPattern Matching – identifying patterns and recognizing when two patterns are similar\nAbstraction – ignoring irrelevant details and reducing a problem to its essential features\nDecomposition – Breaking a complex problem down into smaller and more simpler tasks and then solving each one individually\nAlgorithms – using a sequence of steps to solved a problem\n\n\n--- Slide 4 ---\n\nComputational Thinking\n\nA complex problem is one that, at first glance, we don't know how to solve easily.\nComputational thinking involves taking that complex problem and breaking it down into a series of small, more manageable problems (decomposition). Each of these smaller problems can then be looked at individually, considering how similar problems have been solved previously (pattern recognition) and focusing only on the important details, while ignoring irrelevant information (abstraction). Next, simple steps or rules to solve each of the smaller problems can be designed (algorithms).\nFinally, the algorithms are used to program a computer to help solve the complex problem in the best way\n\n\n--- Slide 5 ---\n\nDecomposition\n\nDecomposition is breaking a complex problem down into smaller and more simpler tasks and then solving each one individually.\nIt is a way of thinking about artefacts in terms of their component parts.\n\n\n--- Slide 6 ---\n\nDecomposition\n\nFor example, making breakfast can be broken down, or decomposed, into separate activities such as make toast; make tea; boil egg; etc.  Each of these, in turn, might also be broken down into a set of steps.\nConsider developing a game: different people can design and create the different levels independently, provided that key aspects are agreed in advance. A simple arcade level might also be decomposed into several parts, such as the life-like motion of a character, scrolling the background and setting the rules about how characters interact.\n\n\n--- Slide 7 ---\n\nDecomposition (Exam Question Ordinary)\n\n\n--- Slide 8 ---\n\nDecomposition (Exam Question Ordinary)\n\n\n--- Slide 9 ---\n\nPattern Matching\n\nidentifying patterns, similarities and connections, and exploiting those features. It is a way of quickly solving new problems based on previous solutions to problems. \nAsking questions such as “Is this similar to a problem I’ve already solved?” and “How is it different?” are important here, as is the process of recognising patterns both in the data being used and the processes/strategies being used.  Algorithms that solve some specific problems can be adapted to solve a whole class of similar problems..\n\n\n--- Slide 10 ---\n\nPattern Matching (Example)\n\nA pupil uses a floor turtle to draw a series of shapes, such as a square and a triangle.  The pupil writes a computer program to draw the two shapes.  They then want to draw an octagon and a 10-sided shape.  From the work with the square and triangle, they spot that there is a relationship between the number of sides in the shape and the angles involved.  They can then write an algorithm that expresses this relationship and use it to draw any regular polygon.\n\n\n--- Slide 11 ---\n\nPattern Matching (Exam Question Higher)\n\n\n--- Slide 12 ---\n\nPattern Matching (Exam Question Higher)\n\n\n--- Slide 13 ---\n\nPattern Matching (Exam Question Higher)\n\n\n--- Slide 14 ---\n\nPattern Matching (Exam Question Higher)\n\n\n--- Slide 15 ---\n\nVideo for solution to previous question\n\n\n--- Slide 16 ---\n\nPattern Matching (Other Example)\n\n\n--- Slide 17 ---\n\nPattern Matching (Other Example)\n\n\n--- Slide 18 ---\n\nPattern Matching (Exam Question Higher)\n\n\n--- Slide 19 ---\n\nAbstraction\n\nAbstraction – ignoring irrelevant details and reducing a problem to its essential features\nhttps://www.youtube.com/watch?v=jV-7Hy-PF2Q\n\n\n--- Slide 20 ---\n\nAbstraction\n\nAbstraction is the process of making an artefact more understandable through reducing the unnecessary detail. A classic example is the London Underground map. London is a highly complex system. The London Underground map is a highly refined abstraction with just sufficient information for the traveller to navigate the underground network without the unnecessary burden of information such as distance and exact geographic position. It is a representation that contains precisely the information necessary to plan a route from one station to another – and no more!\n\n\n--- Slide 21 ---\n\nAbstraction\n\n\n--- Slide 22 ---\n\nUsing Abstraction when designing programs\n\nDefining functions is a very good example of how abstraction can be achieved when designing programs\nE.g. the print() function. The programmer knows what it does and how to use it. The program doesn’t need to know the technical details of exactly how the argument you provide the print function ends up on the screen. These details are “abstracted away” by the function\n\n\n--- Slide 23 ---\n\nAbstraction – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 24 ---\n\nAbstraction – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 25 ---\n\nAbstraction – Leaving Cert Questions (Higher)\n\n\n--- Slide 26 ---\n\nAbstraction – Leaving Cert Questions (Higher)\n\n\n--- Slide 27 ---\n\nAlgorithms\n\nAn algorithm is a sequence of steps required to solve a problem\nAbstraction is a key concern when designing a new algorithm. The level of detail required (level of abstraction) depends on the application of the end program. Designing an algorithm for a robot vacuum cleaner to move around a room in a house requires a different level of abstraction to designing an algorithm to ensure that a self-driving car can travel safely on a street\n\n\n--- Slide 28 ---\n\nAlgorithms\n\nAlgorithms for computers must meet the following criteria:\nBe specific and clear. Every detail and every possibility must be accounted for because computers can’t guess or rely on previous experience\nConsist of a finite number of steps. The algorithm must terminate (no infinite loops)\nHave a clear flow of control from beginning to end\n\n\n--- Slide 29 ---\n\nAlgorithms – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 30 ---\n\nAlgorithms – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 31 ---\n\nAlgorithms – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 32 ---\n\nAlgorithms – Leaving Cert Questions (Ordinary)\n\n\n--- Slide 33 ---\n\nAlgorithms – Leaving Cert Questions (Higher)\n\n\n--- Slide 34 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 35 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 36 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 37 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 38 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 39 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 40 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 41 ---\n\nAlgorithms – Leaving Cert Questions - Higher\n\n\n--- Slide 42 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 43 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 44 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 45 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 46 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 47 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 48 ---\n\nAlgorithms – Leaving Cert Questions\n\n\n--- Slide 49 ---\n\nAlgorithms – Leaving Cert Questions",
          "file": "Notes/12 - Computational Thinking.pptx"
        },
        {
          "id": "23",
          "title": "Searching & Sorting Algorithms",
          "content": "--- Slide 1 ---\nSearching & Sorting Algorithms\nSimple (selection) sort, bubble sort, insertion sort, quick sort.\nLinear (Sequential) search, binary search\nChp 9 page 209\n\n--- Slide 2 ---\nTutorials for sorting and searching algorithms\nVisual Representation of the Sorting Algorithms\nhttps://visualgo.net/en/sorting\n\nVideo Tutorial – how not to forget the sorting and searching algorithms\nhttps://www.youtube.com/watch?v=zuwBCImIyaw\nSearching Algorithms\nLinear Search\nBinary Search\nSorting Algorithms\nInsertion Sort\nBubble Sort\nSimple (Selection) Sort\nQuick Sort (HL)\n\n--- Slide 3 ---\nSearching & Sorting Algorithms\n\n--- Slide 4 ---\nLinear Search\nA linear search checks each item of the list in turn to see if it’s the correct one.\nIt stops when it either finds the item its looking for, or has checked every item in the list\nVisual representation of the sorting algorithms\n\n--- Slide 5 ---\nLinear Search\n\n--- Slide 6 ---\nLinear Search\n\n--- Slide 7 ---\nLinear Search Code\nThe function returns a -1 if no match was found. -1 is used because index -1 does not exist. This lets programmer know no key was found.\nThis code only returns the location of the index the first time the key was found.\n\n--- Slide 8 ---\nLinear Search - Pros and Cons\nPros\nWill perform fast searches of small to medium lists. With today's powerful computers, small to medium arrays can be searched relatively quickly.\nThe list does not need to sorted. Unlike a binary search, linear searching does not require an ordered list.\nNot affected by insertions and deletions. As the linear search does not require the list to be sorted, additional elements can be added and deleted. As other searching algorithms may have to reorder the list after insertions or deletions, this may sometimes mean a linear search will be more efficient.\nCons\nSlow searching of large lists. For example, when searching through a database of everyone in the Northern Ireland to find a particular name, it might be necessary to search through 1.8 million names before you found the one you wanted. This speed disadvantage is why other search methods have been developed.\n\n--- Slide 9 ---\nExam Question (Ordinary)\n\n--- Slide 10 ---\nExam Question (Ordinary)\n\n--- Slide 11 ---\nExam Question (Ordinary)\n\n--- Slide 12 ---\nBinary Search\nA binary search differs from a linear search as it requires that the list is already sorted and takes advantage of this. We can use the built-in function .sort() for this \nBinary search is known as “divide and conquer” algorithm where the problem in hand, is divided into smaller sub-problems and then each problem is solved independently\n\n--- Slide 13 ---\nBinary Search\n\n--- Slide 14 ---\nBinary Search\n\n--- Slide 15 ---\nBinary Search Tutorial Video\nhttps://www.youtube.com/watch?v=KXJSjte_OAI\n\n--- Slide 16 ---\nBinary Search- Pros and Cons\nPros\nOne of the main advantages of a binary search is that it is much quicker than a linear search because the data that needs to be searched halves with each step. For example, it is possible to search through 1024 values and find the one you want within 10 steps, every time.\nCons\nThe biggest problem with a binary search is that you can only use this if the data is sorted into an order.\n\n--- Slide 17 ---\nLinear Search vs Binary Search\nA linear search is much simpler than a binary search, but not as efficient. A linear search can be used on any type of list. The list DOES NOT have to be ordered. Due to its inefficiency , a linear search is often only used on small lists.\nOnce the list has been ordered, a binary search is much more efficient than a linear search. A binary search takes fewer steps to find the item you’re looking for, making it more suitable for large lists of items\n\n--- Slide 18 ---\nCode for the binary search\n\n--- Slide 19 ---\nExam Question (Ordinary)\n\n--- Slide 20 ---\nExam Question (Ordinary)\nDivide the list by 2 each time\n\n--- Slide 21 ---\nExam Question (Higher 2020 Q13)\n\n--- Slide 22 ---\nExam Question (Higher 2020 Q13)\n\n--- Slide 23 ---\nExam Question (Higher 2020 Q13)\n\n--- Slide 24 ---\nSORTING ALGORITHMS\nFor leaving cert you will need to know these 4 sorts:\nInsertion Sort\nSimple Sort also known as Selection Sort\nBubble Sort\nQuicksort (Higher Level only)\n\n--- Slide 25 ---\nSorting Algorithms – Insertion Sort\nThis is the simplest sorting algorithm to understand. It takes each item in turn and puts it in the correct place using the first item in the list as the starting point.\nThis is an in-place comparison-based sorting algorithm. This means all sorting done on original list, it doesn’t require much additional memory\n\n--- Slide 26 ---\nInsertion Sort Example\n\n--- Slide 27 ---\nInsertion Sort - Pros and Cons\nPros\nIntuitive way to sort the list and easy to code\nCopes very well with small lists\nAll sorting done on original list, so like bubble sort, it doesn’t require much additional memory\nVery quick to add items to already ordered list\nVery quick way to check if list is already sorted\nCons\nSimilar to bubble sort, it doesn’t work well with very large lists\nBest case scenario (when list is already sorted) requires n-1 comparisons\nWorst case scenario requires          n(n-1)/2 comparisons\n\n--- Slide 28 ---\nThe Insertion Sort – Video Tutorial\nhttps://www.youtube.com/watch?v=OGzPmgsI-pQ\n\n--- Slide 29 ---\nThe Insertion Sort – The Code\n\n--- Slide 30 ---\nExam Questions – Higher Level\n\n--- Slide 31 ---\nExam Questions – Higher Level\n\n--- Slide 32 ---\nExam Questions – Higher Level\n\n--- Slide 33 ---\nThe Bubble Sort\n\n--- Slide 34 ---\nBubble Sort Example\n\n--- Slide 35 ---\nThe Bubble Sort\nPros\nIt’s a simple algorithm that is easy to implement\nIt’s an efficient way to check if a list is already in order. For a list of n items you only have to do one pass of (n-1) comparisons to check if the list is ordered or not.\nThis is an in-place comparison-based sorting algorithm. This means all sorting done on original list, it doesn’t require much additional memory\nCons\nIt’s an inefficient way to sort a list – for a list of n items, the worse case scenario would involve you doing n(n-1)/2 comparisons. \nDue to being inefficient, the bubble sort algorithm does not cope well with a very large list of items.\n\n--- Slide 36 ---\nThe Bubble Sort - Mistakes Students Make\nA common mistake is to forget the final pass because you realise that the list is already in order. Always show a pass, even if nothing changes to complete the algorithm as a computer would\n\nVideo Tutorial for Bubble Sort\nhttps://www.youtube.com/watch?v=WaNLJf8xzC4\n\n--- Slide 37 ---\nThe Bubble Sort – The Code\n\n--- Slide 38 ---\nExam Question _ Higher Level\n\n--- Slide 39 ---\nSimple or Selection Sort\n\n--- Slide 40 ---\nSimple or Selection Sort\n\n--- Slide 41 ---\nSimple or Selection Sort\n\n--- Slide 42 ---\nSimple or Selection Sort\n\n--- Slide 43 ---\nSimple or Selection Sort\nAlgorithm\n\n--- Slide 44 ---\nThe Selection Sort\nPros\nThe main advantage of the selection sort is that it performs well on a small list. \nIt is an in-place sorting algorithm, so no additional temporary storage is required beyond what is needed to hold the original list\nCons\nThe primary disadvantage of the selection sort is its poor efficiency when dealing with a huge list of items.\nThe selection sort requires n-squared number of steps for sorting n elements. \nIts performance is easily influenced by the initial ordering of the items before the sorting process. Because of this, the selection sort is only suitable for a list of few elements that are in random order.\n\n--- Slide 45 ---\nSimple or Selection Sort – Video Tutorial\nhttps://www.youtube.com/watch?v=xWBP4lzkoyM\n\n--- Slide 46 ---\nSimple or Selection Sort – The Code\n\n--- Slide 47 ---\nExam Questions – Higher Level 2022 - Paper A + B - Question 14\n\n--- Slide 48 ---\nExam Questions – Higher Level\n\n--- Slide 49 ---\nExam Questions – Higher Level\n\n--- Slide 50 ---\nExam Questions – Higher Level\n\n--- Slide 51 ---\nQuick Sort (Higher Level)\nQuickSort is a Divide and Conquer algorithm. A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems, until these become simple enough to be solved directly\nIt picks an element as a pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways. \nAlways pick the first element as a pivot.\nAlways pick the last element as a pivot \nPick a random element as a pivot.\nPick median as the pivot.\n\n--- Slide 52 ---\nQuick Sort (Higher Level)\nhttps://www.youtube.com/watch?v=h8eyY7dIiN4\n \nhttps://towardsdatascience.com/an-overview-of-quicksort-algorithm-b9144e314a72\n\n--- Slide 53 ---\nQuick Sort (Higher Level)\n\n--- Slide 54 ---\nThe quicksort algorithm can be implemented recursively (it calls itself and works on a subset of the problem until a specific point is reached).\nQuick Sort (Higher Level)\n\n--- Slide 55 ---\nThe quicksort algorithm can be implemented recursively (it calls itself and works on a subset of the problem until a specific point is reached).\nQuick Sort (Higher Level)\n\n--- Slide 56 ---\nThe quicksort algorithm can be implemented recursively (it calls itself and works on a subset of the problem until a specific point is reached).\nQuick Sort (Higher Level)\n\n--- Slide 57 ---\nThe quicksort algorithm can be implemented recursively (it calls itself and works on a subset of the problem until a specific point is reached).\nQuick Sort (Higher Level)\n\n--- Slide 58 ---\nThe Quick Sort\nPros\nThe quick sort is regarded as the best sorting algorithm. \nIts significant advantage in terms of efficiency because it is able to deal well with a huge list of items.\nIt is an in-place sorting algorithm so no additional storage is required as well.\nCons\nThe slight disadvantage of quick sort is that its worst-case performance is similar to average performances of the bubble, insertion or selections sorts. \nDifficult to implement due to the recursion\nIn general, the quick sort produces the most effective and widely used method of sorting a list of any item size.\n\n--- Slide 59 ---\nThe Quick Sort – The Code\n\n--- Slide 60 ---\nExam Questions – Higher Level - 2020 - Sample Paper A&B - Question 15\nThe worst case occurs when the picked pivot is always an extreme (smallest or largest) element. This happens when input array is sorted or reverse sorted and either first or last element is picked as pivot. This first results in 2 sublists: one of length (0) and one of length (n-1). The pivot value then needs to be compared with all (n-1) of the other values. If you pick the worst pivot on each recursion, you'll only have one group to sort, with everything in that group other than the original pivot that you picked. This in essence gives you n groups that each need to be iterated through n times, hence the O(n^2) complexity\n\n--- Slide 61 ---\nExam Questions – Higher Level\n\n--- Slide 62 ---\nExam Questions – Higher Level\n\n--- Slide 63 ---\nAlgorithms Time Complexity (HL)\nSometimes there are more than one algorithm to solve a problem. e.g.\nYou learned 2 searching algorithm: Linear & Binary\nYou learned 4 sorting algorithms: Insertion, Bubble, Selection, Quicksort\n\nAlgorithmic Complexity is an important area in computing. Algorithmic Complexity is a measure of how long an algorithm would take to complete, given an input size of n. \n\nBig O notation is used to describe algorithmic complexity\n\n--- Slide 64 ---\nAlgorithmic Time Complexity (HL)\nhttps://www.youtube.com/watch?v=RGuJga2Gl_k\n\n--- Slide 65 ---\nBig O – Algorithmic Complexity\n\n--- Slide 66 ---\nBig O – Algorithmic Complexity\n\n--- Slide 67 ---\nBig O – Algorithmic Complexity\n\n--- Slide 68 ---\nIntractable Problems and Heuristics - HL\nThere are many simple but important problems that are considered to be intractable i.e. no algorithms can solve them in a reasonable amount of time\nOne such problem is the travelling salesperson problem. A travelling salesperson needs to visit n towns. The sales person starts at one of the towns. The distance between each of the towns is known. The problem is : which route, visiting all the towns, then returning back to the starting point, covers the least distance?\n\n--- Slide 69 ---\nIntractable Problems and Heuristics - HL\nThe travelling salesperson problem is very similar to many real life problems involving planning, deliveries etc.\nThere is no known algorithm to solve this problem exactly, in an efficient way, even for a relatively small number of towns. \nThe straightforward solution of just trying all the available options turns out to be O(n!) . Even with just 30 towns that ends up with 265252859812191058636308480000000 combinations. The fastest computer would require many millions of years to check all of these.\n\n--- Slide 70 ---\nIntractable Problems and Heuristics - HL\nWhat can be done with problems such as the travelling salesperson. Heuristic algorithms are one solution. A heuristic algorithm is not guaranteed to return the exact answer, but one that is sufficient.\nA Heuristic algorithm allows us to produce an approximate, but useable solution to the problem.\nUsing heuristics with problems to be solved by the computer involves making a small change that sacrifices something e.g. accuracy or precision,  in order to reduce the time taken to complete the algorithm.\n\n--- Slide 71 ---\nIntractable Problems and Heuristics - HL\nBy using heuristics, sometimes the problem is changed slightly. This can produce a solution that is close enough to that of the original to be acceptable.\nIt is possible to mathematically guarantee that the solution to the problem found using heuristics is within some close limit of the original problem’s answer.\nMany heuristic algorithms written for the travelling salesman problem are estimated to be within a 5% degree of accuracy of the original answer.\n\n--- Slide 72 ---\nThe Travelling Salesman Problem",
          "file": "Notes/23 - Searching & Sorting Algorithms.pptx"
        }
      ]
    },
    {
      "title": "Web & Databases",
      "notes": [
        {
          "id": "22",
          "title": "Introduction to databases",
          "content": "--- Slide 1 ---\nIntroduction to databases\nComputer Science\nLeaving Cert\n\n--- Slide 2 ---\nLesson Objectives\nStudents will learn about:\nThe difference between structured data and unstructured data\nThe database and its structure\nThe relational database and its advantage over a flat-file database\nHow entities (or tables) are related to each other in a relational database.\n2\n\n--- Slide 3 ---\nContent\n1.\n\n--- Slide 4 ---\nWhat is a database?\nA database is an organised collection of data, that allows users to access and search the information easily.\n4\n\n--- Slide 5 ---\nAdvantages of using database\nDatabases are better storage techniques compared to file systems. \nMany users can access the data at the same time.\nDatabases can hold very large amounts of data.\nThe data is only stored once and, hence, data duplication is avoided. \nThe data is consistent as the changes need to be made only once. These changes are then reflected for all the users using the database.\nThe data is stored in an organised way, which makes it easier and faster to carry out searches of the data\nDatabases can interact with many different types of systems e.g. phone apps, web pages, business software\n5\n\n--- Slide 6 ---\n6\n\n--- Slide 7 ---\nFlat File Database (the simplest)\nThe simplest form of database is called a flat file. An example is a .csv file\nA flat file  database contains only a single table. For example: contact details, product details, etc. A table is a collection of related data and is made up of rows and columns. \nEach row represents a record in the database. A record holds specific items of data about someone of something\n7\n\n--- Slide 8 ---\nStructure of a table: Example\n8\nEmployee number\nName\nGender\nDate of birth\nDepartment\nDate of joining\nSalary\nRecord 1\nRecord 2\n\n--- Slide 9 ---\nFlat File Database (the simplest)\nIn a database table, an attribute refers to a column name and the data that it contains\n\n\n\nThe term record is used to refer to one entry (or row) in the database. Each record contains various fields\n9\n\n--- Slide 10 ---\nDatabase Data Types\nEach attribute in the database table contains a specific type of data, just like python variable types (string, Boolean, integer, float)\nVarchar -> the first attribute in our table below contains a string. In database terminology, a string is called a varchar. \nNumber -> The attributes labelled phoneNum and age contain numbers. These are of datatype number. \nDate -> The attribute labelled DOB contain the data type date.\n10\n\n--- Slide 11 ---\nCreating a database (flat file)\n11\n\n--- Slide 12 ---\nAppending records to the CSV file\n12\n\n--- Slide 13 ---\nRead and Display records from the CSV file\n13\n\n--- Slide 14 ---\nStructured vs. unstructured data\nUnstructured data\nInformation that is not structured in a predefined manner is called unstructured data. \nData in a word document or notepad are examples of unstructured data.\nStructured data\nInformation that is stored in a predefined manner, that is, in a structure is called structured data.\n Databases help us to store data in a structured manner.\n14\n\n--- Slide 15 ---\n15\n\n--- Slide 16 ---\nIssues with single table of data\nThe table contains details of patients’ record in a doctor’s clinic. If we were to build a database system for a doctor’s clinic, you will need to cross-reference by doctor as well as patient. \nEach doctor has many patients, but each patient normally has only one doctor\nNotice the duplication of data for the doctors in the below file.\n16\n\n--- Slide 17 ---\nIssues with single table of data\nNotice the duplication of data for the doctors in the below file. This causes problems such as:\nWasted time/effort when entering and updating the data. Every occurrence of the doctor attributes will need to be updated if a detail changes e.g doctor retires or changes jobs.\nWasted storage space as duplicated data takes up extra memory space\n17\n\n--- Slide 18 ---\nWhat is a relational database?\nA relational database is a type of database that is structured  and is distributed over various tables that are connected using a relationship in a relational database. Hence, no redundant data.\n18\n\n--- Slide 19 ---\nUse or two or more related tables\n - Relational Database\nIt is better practice to split this information into 2 tables. Then define a relationship between the table\nA patient’s table\nA Doctor’s table\n19\nPatient’s Table\nDoctor’s Table\n\n--- Slide 20 ---\nPrimary key\nThe purpose of a primary key is to provide a unique key to a record.\nTo prevent data duplication, each record uses a primary key field, which must be unique. It can be automatically generated. \nA primary key may be just numbers or a combination of letters and numbers. \nIn the employee table, an employee number is unique for each employee and serves as the primary key.\n20\n\n--- Slide 21 ---\nUse or two or more related tables\n - Relational Database\nFirst, need to create a PRIMARY KEY for Each patient record and each doctor record\n21\nPatient’s Table\nDoctor’s Table\n\n--- Slide 22 ---\nRelational Database – The Foreign Key\nIn the patient’s table a new attribute (column) is added called  doctorID. This creates the link (relationship) back to the doctor’s table. This is the FOREIGN KEY and it is always the primary key from the other table with which you want to make the link\n22\nPatient’s Table\nDoctor’s Table\n\n--- Slide 23 ---\nRelational database\nA large set of data is distributed over various tables and connected using a relationship in a relational database. Hence, no redundant data.  \nA relational database is efficient over flat-file databases as it is more efficient and takes up less space in memory.\nFlat-file database\nPresence of redundant data, that is, repetition of data in a database.\nDue to the presence of redundant data, more memory space is required and it is also less efficient.\n23\nRelational databases vs. Flat file databases\n\n--- Slide 24 ---\nAdvantages of using a relational database\nFor example, a library may store information such as a book list, member list, department, book location, research paper list, staff details and many more. \nStoring these details in a single flat-file system would lead to more memory space requirement and data redundancy.\n24\n\n--- Slide 25 ---\nCharacteristics of relational database\nAn entity is an object in a system for which the information is stored. \nA characteristic of an entity is its attribute. \nIn a record, attributes about an entity are stored. \nFor example, let us consider a book as an entity. \nAuthor, name of the publisher, year of publication, price of the book, and ISBN number are its attributes.\n25\nEntity: Book\nAttributes:\nAuthor\nName of publisher\nYear of publication\nISBN number\n\n--- Slide 26 ---\nCharacteristics of relational database\nIn a relational database, each table contains information about just one entity. \nEach table has a primary key and these tables are linked together using these primary keys and foreign keys. \nForeign keys are a link to primary keys.\n26\n\n--- Slide 27 ---\nCharacteristics of relational database: Example\nLet us consider the database of a library with three tables:\nBook with a primary key BookID \nMember with primary key MemberID\nBookslent with foreign keys Book ID and Member ID\n27\n\n--- Slide 28 ---\nCharacteristics of relational database: Example\nThe entity descriptions for the entities book and member are given as:\nBook (BookID, Title, Author, Publisher)\nMember(MemberID, FirstName, LastName, ValidUntil, PhoneNumber)\nThe primary key is underlined in entity descriptions.\n28\n\n--- Slide 29 ---\n29\nBook:\nBookID\nTitle\nAuthor\nPublisher\n1\nCambridge IGCSE Computer Science\nDavid Watson and Helen Williams\nHodder Education\n2\nComplete Chemistry for Cambridge IGCSE\nPaul Ingram and Rosemarie Gallagher\nOxford University Press\n3\nComplete Mathematics for Cambridge IGCSE\nDavid Rayner\n4\nCambridge International AS and A Level Computer Science Coursebook\nDave Duddell and S. Langfield\nCambridge University Press\n\n--- Slide 30 ---\n30\nMember:\nMemberID\nFirstName\nLastName\nValidUntil\nPhoneNumber\nM18535\nStephen\nWatson\n31/12/2019\n1864012854\nM11935\nMary\nRayner\n5/10/2020\n7911039811\nM25183\nMarian\nMiller\n4/11/2018\n8111092210\n\n--- Slide 31 ---\n31\nBookslent table:\nIt can be noticed that other attributes of books and members are not included, as these are referenced using their respective IDs.\nBook ID and Member ID are the foreign keys of this table that act as a reference to other tables. These foreign keys also act as primary key for this table.\nBook ID\nMember ID\nDate\nFine\n2\nM18535\n12/10/2018\n0\n1\nM11935\n15/9/2018\n£ 1\n3\nM25183\n21/07/2018\n£ 3\n\n--- Slide 32 ---\nReferential integrity\nReferential integrity ensures that all foreign keys represent a valid and existing primary key in its parent table. \nFor example: In Books table, if you delete the record for BookID=2, it will create an orphaned record (shown in red colour) in Bookslent table.\n32\nBookID\nMemberID\nDate\nFine\n2\nM18535\n12-10-2018\n0\n1\nM11935\n15-9-2018\n£ 1\n3\nM25183\n21-07-2018\n£ 3\n\n--- Slide 33 ---\nRelationship between entities (tables)\nEntities(table) are related to each other using one of the following relationships:\nOne to one\nOne to many\nMany to many\n33\n\n--- Slide 34 ---\nRelationship between entities: One to one\nOne entity is related to another entity only. For example: A person has one email address.\n34\nPerson\nEmail iD\nCourse 3\nStudent 3\nhas\n\n--- Slide 35 ---\nRelationship between entities: One to many\nOne entity is related to many entities. For example: A library has many members.\n35\nLibrary\nMember\nhas\n\n--- Slide 36 ---\nRelationship between entities: Many to many\nMany entities are related to many entities. For example: Many students can take a course and a course can have many students.\n36\n\n--- Slide 37 ---\nLet’s review some concepts\nDatabase\nA database is an organised collection of data, which allows users to obtain and process information according to their requirements.\nStructure of a database\nData in a database is stored in the form of tables.\nTable\nA table consists of various records. Each record consists of several fields.\n37\nRelational database\nA relational database is a type of database that is structured and allows users to identify and access data which is in relation to other data.\nEntity\nAn entity is an object in a system for which the information is stored. In a relational database, each table contains information about just one entity.\nAttribute\nA characteristic of an entity is its attribute. In a record, attributes about an entity are stored.\n\n--- Slide 38 ---\nActivity\n2.\n\n--- Slide 39 ---\nActivity-1\nDuration: 20 minutes\nAn online airline ticket-booking websites process the customer’s request, shows available flight details with price and prompts the user to select one of them, books the tickets and sends a copy of the ticket to the customer’s email address.\nIdentify the entities(tables) in the above scenario.\nWhat relationship exists between these entities? Draw flowcharts to explain your answer.\n39\n\n--- Slide 40 ---\nActivity-1\nDuration: 20 minutes\nWhat tables do you require for an online airline ticket booking website? Show the attributes of all entities. Mark the primary keys and foreign keys (if any) of each table. Show the relationship between tables as a flowchart.\n40\n\n--- Slide 41 ---\nEnd of topic questions\n3.\n\n--- Slide 42 ---\nEnd of topic questions\nWhat is a database? What are the advantages of using a database?\nWhat are the applications of the database?\nHow is a database structured?\nWhat is a relational database? What are its advantages over a flat-file database?\nWhat I meant by the term entity, record and attributes? How are these represented in the form of a table?\n42\n\n--- Slide 43 ---\nEnd of topic questions\nWhat is the difference between a primary key and foreign key?\nWhat are the different relationship between entities? Give examples for each relationship with entity-relationship diagrams.\n43\n\n--- Slide 44 ---\nEnd of topic questions\nA car dealer builds a database for the following entities:\nCustomer (CustomerID, FirstName, LastName, PhoneNumber)\nCar (ProductCode, Brand, Model, Price)\nOrder (CustomerID, ProductCode, Accessories, TotalPrice)\nDraw the entity relationship diagrams between these entities.\nWhat is the primary key for the Order table? \nWhat is referential integrity? In this database, how is referential integrity maintained?\n44",
          "file": "Notes/22 - Introduction to databases.pptx"
        },
        {
          "id": "27",
          "title": "WWW, Internet &Protocols",
          "content": "--- Slide 1 ---\nWWW, Internet &Protocols\n6th yr Computer Science\n\n--- Slide 2 ---\nThe Internet\nThe Internet is a global network, which allows computers to talk to each other.\nhttps://www.telstra.com.sg/content/dam/shared-component-assets/tecom/networks/global-networks/global-internet/hero-banner.jpg\n\n--- Slide 3 ---\nThe Internet\nIt requires hardware and software to operate and allows vast amounts of data to be transmitted over land and under oceans, from one side of the world to the other.\nRouters, switches and servers in millions of locations around the globe use over 300 underwater cables and countless cables above ground to connect to each other.\n\n--- Slide 4 ---\nThe World Wide Web\nThe World Wide Web (WWW) is an application that runs on the Internet.\nThere are many applications and protocols operating on the Internet that provide the services we use every second of every day.\nHTTP\nHTML\nURL\nCSS\nDNS\nJavascript\nFTP\nEmail\n\n--- Slide 5 ---\nThe World Wide Web\nThe World Wide Web (WWW) uses the Internet as a transmission medium. Without the Internet, the Web wouldn’t work.\n\nThe web was invented by Tim Berners-Lee in 1989. He created a way of putting websites onto the Internet. All these websites together are what is known as the World Wide Web.\n\nThink of the Web as a vast collection of documents (often HTML that represent web sites) with links to each other.\n\nThe web is only one use of the Internet. Other uses are email, instant messaging, streaming services etc\n\n--- Slide 6 ---\nClient Server Relationships\nWhen you visit a web page, your computer (the client) issues a request that eventually makes its way to the appropriate server.\n\nThe server is a computer that provides resources or services to other computers.\n\nThe server then carries out that request and the information representing the webpage/resources is transmitted back to your computer(the client)\n\nYour browser then renders the information received into the website you see.\n\n--- Slide 7 ---\nClient Server Relationships\nClient - Server Model\n\nThe WWW application uses the client-server model to communicate.\n\nThere are two sides in this model:\nServer (a device where data is stored)\nWeb Server\nEmail Server\n\nClient (the applications on our phones, tablets & computers)\nInternet Browser\nEmail Application\n\n--- Slide 8 ---\nClient Server Relationships\nClient - Server Model\n\nIn general, CLIENTS request the resources or services and servers provide them.\n\nThe client-server model is a simple distributed (shared) system. A distributed system is where the workloads required to complete a task are shared between more than one computer. These computers are connected by a network, over which messages re sent in order to complete the required task.\n\n--- Slide 9 ---\nCommunication Protocols\nA communication protocol is a set of rules describing how to transmit data across a network. This network , can be the internet.\n\nThe client server model uses several different protocols, each governing communication in its own protocol LAYER of the network. Without these protocol (set of rules) the client server model would not work.\n\n--- Slide 10 ---\nTCP / IP Suite of Protocols\nTransmission Control Protocol / Internet Protocol (TCP/IP) refers to a suite of protocols used to send and receive messages over the internet. The TCP/IP protocol suite contains a number of different layers.\n\n1. **Application Layer**: encodes / decodes the message into a form that is understood by the sender and the recipient devices using protocols such as HTTP, FTP and SMTP.\n   \n2. **Transport Layer**: **: breaks down the message into small pieces called packets. Each packet is given a packet number and the total number of packets. The recipient uses this information to re-assemble the packets in the correct order. It also allows the recipient to see if there are any missing packets. .This  uses protocols like TCP (Transmission Control Protocol)\n\n--- Slide 11 ---\nTCP / IP Suite of Protocols\nTransmission Control Protocol / Internet Protocol (TCP/IP) refers to a suite of protocols used to send and receive messages over the internet. The TCP/IP protocol suite contains a number of different layers.\n\n3. **Internet Layer**: Also known as the Network Layer,adds the sender’s IP address and that of the recipient. The network then knows where to send the message, and where it came from. The primary protocol at this layer is IP (Internet Protocol\n   \n4. **Link Layer**: enables the physical transfer of packets between nodes on a network, and between one network and another. It includes protocols that govern communication within a single network segment, such as Ethernet or Wi-Fi\n\n--- Slide 12 ---\nCommunication Protocols\nClient - Server Model\nThis is the path taken by a client request, via the internet, to a particular server.\nThe request travels “down” through the the protocol layers in the client, \nthen through the internet,\nThe passes “up” through the protocol layers in the server.\nRequest is then handled by the server and the information is sent back to the client via the same path\n\n--- Slide 13 ---\nExam Questions\n\n--- Slide 14 ---\nExam Questions\n\n--- Slide 15 ---\nExam Questions\n\n--- Slide 16 ---\nHTTP (Communication Protocols)\nHTTP – Hyper Text Transfer Protocol -> Application Layer\n- Shown at the beginning of web addresses\nOperates in the application (program) layer of the network\nKnown as the request-response protocol as it allows a client to issue a request for a resource (e.g. website) and the server to respond to the right computer with the resource required.\n\n--- Slide 17 ---\nHTTPS (Communication Protocols)\nHTTPS - Hyper Text Transfer Protocol Secure\n- is the secure version of HTTP which automatically encrypts all traffic to and from the server.\n- theoretically, anyone intercepting communications between the client and the server can’t read the messages. (They are encrypted)\n- This has allowed for secure banking and online shopping to become as popular as they are.\n\n--- Slide 18 ---\nTCP (Communication Protocols)\nTCP – transmission control protocol -> Transport Layer\nTCP operates at the transport layer, \nThe message is broken into “packets” for efficient routing\nbreaks down the message into small pieces called packets. Each packet is given a packet number and the total number of packets. The recipient uses this information to re-assemble the packets in the correct order. It also allows the recipient to see if there are any missing packets.\n\n--- Slide 19 ---\nIP  - Internet protocol (Communication Protocols) -> Network Layer\nIP operates at the network layer.\nIP is responsible for the routing of packets from the source device to the destination device via a network of inter-connected computer called the internet\nDoes this using IP addresses e.g  192.168.4.210\nIP address is a unique code that identifies a computer network or particular computer on a network.\n\n--- Slide 20 ---\nWiFi (Communication Protocols) -> Physical Layer\nThe WiFi protocol operates at the physical layer. It manages the flow of data around a WiFi network such as the one in your home.\nWiFi is the radio wave technology that allows devices (phones, TVs, laptops, printers) to communicate with each other and access the internet wirelessly.\n\n--- Slide 21 ---\nRecap of TCP/IP Protocol Layers Recap\nVideo -> What is TCP/IP?\n\n--- Slide 22 ---\nInternet Hardware Components\nThe internet is made up of many different hardware components  that connect the end-user devices such as computers or laptops.\nThese internet hardware components move data from place to place and include gateways, routers, bridges, switches and repeaters\n-These components typically connect to each other over a combination of radio signals, copper cables and fibre optic cables\nIntroduction to Network Devices\n\n--- Slide 23 ---\nCloud Computing\nCloud computing is a technology that uses the internet for storing and managing data on remote servers and then access data via the internet. This type of system allows users to work on the remote. Cloud computing customers do not own the physical infrastructure; they rent the usage from a third-party provider.\nThese third party providers are responsible for keeping the data available, accessible and secure. Customers need only pay for as much storage and processing power as they require\n\n--- Slide 24 ---\nWhat are the security threats faced by computer users ?\n\n--- Slide 25 ---\nWhat are the security threats faced by computer users ?\n\n--- Slide 26 ---\nWhat is Malware ?\nMalware, or malicious software, is any program or file that is intentionally harmful to a computer, network or server.\n\nThe aim of malware is :\ndamage or delete files\nSteal information\nTake control of the system\n\nWhat are the different types of malware?\nDifferent types of malware have unique traits and characteristics. Types of malware include the following:\nA virus is the most common type of malware that can execute itself and spread by infecting other programs or files.\nA worm can self-replicate without a host program and typically spreads without any interaction from the malware authors.\nA Trojan horse is designed to appear as a legitimate software program to gain access to a system. Once activated following installation, Trojans can execute their malicious functions.\n\n--- Slide 27 ---\nDifferent Types of Malware ?\nSpyware collects information and data on the device and user, as well as observes the user's activity without their knowledge.\nRansomware infects a user's system and encrypts its data. Cybercriminals then demand a ransom payment from the victim in exchange for decrypting the system's data.\nA rootkit obtains administrator-level access to the victim's system. Once installed, the program gives threat actors root or privileged access to the system.\nA backdoor virus or remote access Trojan (RAT) secretly creates a backdoor into an infected computer system that enables threat actors to remotely access it without alerting the user or the system's security programs.\nAdware tracks a user's browser and download history with the intent to display pop-up or banner advertisements that lure the user into making a purchase. For example, an advertiser might use cookies to track the webpages a user visits to better target advertising.\nKeyloggers, also called system monitors, track nearly everything a user does on their computer. This includes emails, opened webpages, programs and keystrokes\n\n--- Slide 28 ---\nHow is malware spread ?\nMalware is spread in simple ways that trick people or take advantage of weak spots in computers. Here are the main ways:\nEmail Attachments or Links: You get an email that looks real, but it has a file or link that, when clicked, installs malware.\nInfected Websites: You visit a website that secretly downloads malware onto your device, especially if your browser or software isn’t up to date.\nFake Apps or Software: You download an app or program that looks legit but actually contains malware.\nUSB Drives: Plugging in an infected USB stick can spread malware to your computer.\nSocial Media or Messages: Links sent through social media or messaging apps can lead to malware-infected sites.\nSoftware Vulnerabilities: Hackers can exploit flaws in programs or operating systems to install malware without you doing anything.\n\n--- Slide 29 ---\nMalware, how to protect yourself ?\nHere are some simple and effective tips to protect yourself from malware:\nDon't click on suspicious links or attachments – Even if it looks like it’s from someone you know, be cautious.\nUse antivirus software – It helps detect and block malware before it can harm your system.\nKeep software updated – Updates often fix security holes that malware can exploit.\nDownload apps and programs only from trusted sources – Stick to official websites and app stores.\nUse strong, unique passwords – This helps prevent hackers from breaking into your accounts.\nBack up your data regularly – If malware strikes, you won’t lose your important files.\nBe cautious with public Wi-Fi – Use a VPN if you need to access sensitive information on public networks.\n\n--- Slide 30 ---\nWhat is artificial intelligence (AI) ?\nArtificial Intelligence is the capability of a computer system to mimic human cognitive functions such as learning and problem-solving.\nExamples of Artificial intelligence\n•Autonomous vehicles: AI is used to enable self-driving cars, which use sensors and machine learning algorithms to navigate roads and make driving decisions.\n•Healthcare: AI is used in healthcare to analyze medical images, assist in diagnosis, and develop personalized treatment plans.\n\n--- Slide 31 ---\nDifferent Types of AI\n•Narrow AI: This type of AI is designed to perform a specific task, and it operates within a limited scope. Narrow AI is commonly used in applications such as virtual assistants, image recognition software, and language translation programs.\n\n•General or Strong AI: This type of AI is capable of performing any intellectual task that a human can. However, currently, there is no true strong AI that has been developed, and it remains a theoretical concept.\n\n--- Slide 32 ---\nSimple AI  Vs Machine Learning\nWith simple AI, a programmer can tell a machine how to respond to various sets of instructions by hand-coding each “decision.”\nWith machine learning models, computer scientists can “train” a machine by feeding it large amounts of data. The machine follows a set of rules—called an algorithm—to analyze and draw inferences from the data. The more data the machine parses, the better it can become at performing a task or making a decision.\n\n--- Slide 33 ---\nWhat is Machine Learning\nMachine learning is a way for computers to learn from data and make decisions or predictions without being told exactly what to do.\nThink of it like this:\nInstead of programming a computer with step-by-step instructions, we give it lots of examples (data).\nThe computer looks for patterns in that data.\nThen, it uses those patterns to guess or decide things in the future.\nFor example:\nShow it thousands of photos of cats and dogs, and it learns to tell them apart.\nGive it information about houses and prices, and it can predict how much a new house might cost.\nIt’s like teaching a child by showing examples instead of just giving rules.\n\n--- Slide 34 ---\nTypes of machine learning\n1. Supervised Learning\nThe computer is taught with labeled data (the answers are already given).\nExample: Show pictures of animals with labels like \"cat\" or \"dog\", and the computer learns to tell the difference.\nIt’s like learning with a teacher who gives you the right answers to study.\n2. Unsupervised Learning\nThe computer is given data without any labels and has to find patterns or groups on its own.\nExample: Give it photos of animals, but don’t say what they are—it might group cats together and dogs together by noticing similarities.\nIt’s like solving a puzzle without any instructions.\n\n--- Slide 35 ---\nTypes of Machine Learning\n3. Reinforcement Learning\nThe computer learns by trial and error, getting rewards or penalties.\nExample: Like training a dog—if it does the right thing, it gets a treat.\nUsed in things like game-playing robots or self-driving cars.\n\n--- Slide 36 ---\nPositives of AI\n1. Saves Time\nAI can do tasks faster than humans, like sorting emails or answering simple questions.\n\n\n2. Works 24/7\nAI doesn’t get tired—it can work all day and night without breaks.\n\n\n3. Helps in Healthcare\nAI helps doctors by finding diseases earlier, reading X-rays, or suggesting treatments.\n\n--- Slide 37 ---\nPositives of AI\n4. Smart Assistants\nTools like Siri, Alexa, or Google Assistant make life easier by helping with reminders, directions, and more.\n\n\n5. Personalized Recommendations\nAI suggests movies, music, or shopping items you might like, based on your past choices.\n\n\n6. Better Safety\nAI is used in self-driving cars and security systems to help reduce accidents and protect people.\n\n\n7. Solves Big Problems\nAI helps with things like predicting weather, fighting climate change, and advancing science.\n\n--- Slide 38 ---\nProblems with AI\n1. Bias\nAI can be unfair if it learns from biased data.\nExample: If it’s only trained on pictures of light-skinned people, it may not work well for darker-skinned people.\n\n2. Lack of Understanding\nAI doesn’t really understand like humans do—it just finds patterns.\nIt can make strange or wrong decisions if the situation is new or confusing.\n\n3. Job Loss\nAI can replace human workers in some jobs, especially repetitive or routine ones.\n\n--- Slide 39 ---\nProblems with AI\n4. Privacy Concerns\nAI often needs lots of data, which can mean people’s personal information is collected and used without them knowing.\n\n5. Hard to Control\nSome AI systems are so complex that even the people who made them can’t fully explain how they work or why they make certain choices.\n\n6. Misuse\nAI can be used for bad purposes, like fake videos (deepfakes), hacking, or spreading lies.",
          "file": "Notes/27 - WWW, Internet &Protocols.pptx"
        }
      ]
    },
    {
      "title": "Advanced Topics",
      "notes": [
        {
          "id": "18",
          "title": "Data Analytics",
          "content": "--- Slide 1 ---\n\nData Analytics\n\nLC Computer Science\n\n\n--- Slide 2 ---\n\nWhat is Data Analytics\n\nData Analytics involves processing and analysing data with the aim of discovering useful information, informing conclusions, and supporting decision-making\nData Analytics in Football\n\n\n--- Slide 3 ---\n\n\n--- Slide 4 ---\n\nStages of Analytics\n\nAccessing the Data\nPre-processing the data\nAnalysis\nVisualisation\n\n\n--- Slide 5 ---\n\nStage 1 - Accessing the Data\n\nData describes the raw data in formats such as a CSV file, a list or data in a database.\nThe Data is normally not in an organised structure so it is impossible to gain any useful information from it\n\n\n--- Slide 6 ---\n\nStage 1 – A CSV file\n\n\n--- Slide 7 ---\n\nStage 2 - Pre-processing the data\n\nThis stage involves converting the data into a form that is suitable for further analysis.\nTechniques include:\nChecking for outliers and missing data\nSorting data\n\n\n--- Slide 8 ---\n\nStage 2 – Outliers and missing data\n\nAn outlier is a data point that differs significantly from other data points. Must decide either to keep them or remove them from the data set.\nMissing data can cause problems and have a significant effect on the conclusion drawn from the data. Missing data points can be removed from the data set during pre-processing\n\n\n--- Slide 9 ---\n\nStage 3 – Analysis\n\nEven when data is presented graphically, the finer details are not always obvious.\nAlgorithms can offer greater precision to those interpreting the data\nUsing algorithm to calculate frequency, mean, median, mode, minimum, maximum can add clarity and produce information that is easy to understand.\n\n\n--- Slide 10 ---\n\nStage 4 – Visualisation\n\nOnce the data is pre-processed, it can be presented as meaningful information. This is normally presenting the data visually in a graph or picture.\nVisualisation can be carried out before or after pre-processing and analysis\n\n\n--- Slide 11 ---\n\nAccessing the Data -\n\nIn this part we will look at code to read in, store & retrieve data from files stored on you computer\n\n\n--- Slide 12 ---\n\nAccessing the Data – Python Lists\n\nMost analysis such as frequency, mean, medium, minimum, maximum and mode can only be calculated on data held in a list. \nOnce the data is in a list, it’s possible to perform pre-processing\nmyList=[1, 19, 27, 8, 1, 5, 9]\n\n\n--- Slide 13 ---\n\nAccessing the Data – Text Files\n\nA text file is a type of computer file that only contain plain text. There is no formatting or images. Text files have the extension .txt\nText files are widely used to hold data. \nThey are the most versatile type of file as they allow for storing data after your program finishes\n\n\n--- Slide 14 ---\n\nCreating, writing to and closing a text file\n\nWhen writing to a file using Python if the file does not exist, Python automatically creates it.\nWhen reading from a file, if the file does not exist, you get an error.\n\n\n--- Slide 15 ---\n\nCreating, writing to and closing a text file\n\nLine 1: file is just a variable name\nopen() takes 2 arguments\nThe first is a string that contains the filename including its extension\nThe second argument refers to what we are doing with the file\n\n\n--- Slide 16 ---\n\nCreating, writing to and closing a text file\n\nLine 1: file is just a variable name\nopen() takes 2 arguments\nThe first is a string that contains the filename including its extension\nThe second argument refers to what we are doing with the file\n“w” – write. This overwrites any previous contents\n“a” – append. The text is added to the end of what is currently in the file\n“r” – read. The text is read from the file as a string\n\n\n--- Slide 17 ---\n\nRead in contents of text file\n\nDifferences from last code\n“r” indicates that the file is to be read\nVariable dataIn used to store all the contents of the file that is read using file.read()\n\n\n--- Slide 18 ---\n\nAccessing the Data – CSV file\n\nText files are useful but are not very suitable for storing numerical data, such as multiple temperature readings\nThere is no standard way to separate each value in a text file so a computer can read each value separately.\nCSV files are used to store numerical data. Commas are used to separate data items.\nFile extension is .csv\n\n\n--- Slide 19 ---\n\nCreate a CSV file\n\nCreate a file in excel and open it\nEnter 5 numbers in adjacent cells in the first row\nSave as a .csv file and open it using notepad, not excel\n\n\n--- Slide 20 ---\n\nAdvantages of CSV files\n\nPython can read and write to them quickly (same as text file)\nExcel has a limit on the number of rows it can have. This may not be big enough for some uses.\nMany applications can open and work with CSV files so you can use the file even if you do not have excel.\n\n\n--- Slide 21 ---\n\nCreating, writing to and reading a CSV file\n\nThe code is identical to the text file except for the filename/extension\n\n\n--- Slide 22 ---\n\nReading a CSV file\n\nThe variable dataIn is of type String. When reading a CSV file, the file.read() function reads in the characters as a single string. Some analysis such as the mean, cant be performed on strings\n\n\n--- Slide 23 ---\n\nReading a CSV file\n\nThe variable dataIn is of type String. When reading a CSV file, the file.read() function reads in the characters as a single string. Some analysis such as the mean, cant be performed on strings\n\n\n--- Slide 24 ---\n\nExtracting CSV file to a list\n\nA list is created from the string using the .split() function. The items in the list are still a string\n\n\n--- Slide 25 ---\n\nExtracting CSV file to a list\n\nA list is created from the string using the .split() function. The items in the list are still a string\n\n\n--- Slide 26 ---\n\nConverting string list to int\n\nLine 9 - item is a variable name that appears twice. Must be the same in both locations. Uses square brackets to show its returning a list\n\n\n--- Slide 27 ---\n\nPractice time\n\nUsing the code on the previous page\n\t- create a new .csv file called newCSV.csv and insert 5 float vales into the \tfile.\n\t- Use the .split function to convert the .csv file to a list\n\t- Convert the values from string to float\n\t- Print out the list\n\n\n--- Slide 28 ---\n\nPre-processing Data - Sorting\n\nDuring this stage we apply techniques to ensure the data is of good quality\nSORTING ASCENDING AND DESCENDING\n\nLine 2 – list gets sorted ascending\nLine 4 – list get sorted descending\n\n\n--- Slide 29 ---\n\nPractice Time- 15 mins\n\nPage 77 Task 2\nCreate a text file (in the same folder as your python script file) that contain s a single word that will act as a password. You can select the password\n\nTask 3\nWrite a python program to ask a user to enter a password. Check whether the entered password is the same as the password in the text file.\n\nTask 4\nWrite a python program to ask the user to enter 10 values using a loop. You can assume the values are numbers. Save these values to a .csv file\nHINT: you will need to add the commas in the program to convert the data to.csv format or you can use the append argument\n\n\n--- Slide 30 ---\n\nPre-processing Data – Removing Data\n\nIf item in list is identified as an outlier or invalid, it can be removed\n\n.remove() function will remove all instances of that specific value in the list.\n\n\n--- Slide 31 ---\n\nPre-processing Data – Removing Data\n\nSometimes removing data is not a good option especially if a list is been used with other lists\n\n\n--- Slide 32 ---\n\nPre-processing Data – Removing Data\n\nWe removed the erroneous data in numbs using the .remove() function\nThe order in numBS has changed by removing the missing values. The number of brother and sister no longer match up with the student names correctly\nThere is also 2 instances of missing data\n\n\n--- Slide 33 ---\n\nPre-processing Data – Imputation\n\nImputation involves replacing missing or erroneous data with alternative values\nOne imputation algorithm finds the average of all the non-missing and non-erroneous values and then replaces each missing value with the average\n\n\n--- Slide 34 ---\n\nPre-processing Data – Imputation\n\nThis is useful because:\nIt keep the list the same size and keeps the location of each item\nThe code for the algorithm is easily modified to impute other values, beside the average, depending on the context\nImputation used for scientific and statistical work where it is not practical for people to check each data point\n\n\n--- Slide 35 ---\n\nImputation-Step 1\n\nImputation involves replacing missing or erroneous data with alternative values. Step 1 - find the average of the non-erroneous data\n\n\n--- Slide 36 ---\n\nImputation-Step 2\n\nStep 2 – Replace all error values with calculated averageNonErroneous\n\n\n--- Slide 37 ---\n\nPractice Time- 10 mins\n\nPage 79  - Task 1\nCreate a python program to remove items from a list using a loop\n\nPage 79  - Task 2\nCreate a list of 20 numeric items, then:\n\t- Sort the file in descending order\n\t- Save it as a .csv file\n\t-Find the largest and the smallest number in the list (without using max or min function)\n\n\n--- Slide 38 ---\n\nDefinition of an algorithm\n\nAn algorithm is a sequence of steps required to solve a problem. An algorithm can be described in different ways:\nWritten as a list of steps in english\nFlowchart, to draw each step and show the flow of control\nPseudocode (a mixture of English of English and and programming language)\nhttps://www.youtube.com/watch?v=qwd4piEEyR0 (1.11)\n\n\n--- Slide 39 ---\n\nExample of an algorithm\n\nList of steps in english\n\nFlowchart\n\n\n--- Slide 40 ---\n\nExample of an algorithm\n\nPseudocode – mixture of English and programming language\n\n\n--- Slide 41 ---\n\nFlowchart Symbols\n\n\n--- Slide 42 ---\n\nAlgorithm practice\n\nA sensor to detect lead pollution from a mine has been installed in a local river. \nUse an algorithm \n(i)step by step in english \n(ii) flowchart, \n - to design a program to read in the pollution level, determine if it exceeds the limit, and if it does, send an alert to the local authority.\n\n\n--- Slide 43 ---\n\nStages of Analytics -> Analysis\n\nPython is very popular for analytics because of the speed of writing python code to analyse data.\nimport statistics has functions for minimum, maximum, mean, median, frequency and mode.\n\n\n--- Slide 44 ---\n\nAnalysis - Minimium\n\nmyList=[1, 9, 27, 8, 1, 5, 9]\nMinimium => The smallest value on the list\nSort the list in ascending order: [1, 1, 5, 8, 9, 9, 27]\nExtract the first value from the list => 1\n\n\n--- Slide 45 ---\n\nAnalysis - Maximium\n\nmyList=[1, 9, 27, 8, 1, 5, 9]\nMaximum => The greatest value on the list\nSort the list in ascending order: [1, 1, 5, 8, 9, 9, 27]\nExtract the last value in the list => 27\n\n\n--- Slide 46 ---\n\nFlowchart Symbols\n\n\n--- Slide 47 ---\n\nFlowchart for Minimum & Maximum using sort function\n\n\n--- Slide 48 ---\n\nAnalysis -> Minimum and Maximum\n\n\n--- Slide 49 ---\n\nFlowchart for Minimum without using inbuilt functions\n\n\n--- Slide 50 ---\n\nFlowchart for Maximium without using inbuilt functions\n\n\n--- Slide 51 ---\n\nAnalysis -> Minimum and Maximum\n\n\n--- Slide 52 ---\n\nAnalysis -> Minimum and Maximum\n\n\n--- Slide 53 ---\n\nAnalysis - Mean\n\nmyList=[1, 9, 27, 8, 1, 5, 9]\nMean => The average of the data set\nGet the total => 1+9+27+8+1+5+9 = 60\nDivide by the number of items in dataset => 60 / 7 = 8.57\n\n\n--- Slide 54 ---\n\nFlowchart for Mean without using inbuilt functions\n\n\n--- Slide 55 ---\n\nAnalysis -> Mean Manual Method 1\n\n\n--- Slide 56 ---\n\nAnalysis -> Mean Manual Method 2\n\n\n--- Slide 57 ---\n\nAnalysis -> Mean Manual Method 3\n\n\n--- Slide 58 ---\n\nAnalysis - Median\n\nmyList=[1, 9, 27, 8, 1, 5, 9]\nMedian => The middle number of the dataset\nSort the list in ascending order: [1, 1, 5, 8, 9, 9, 27]\nFind the middle number: [1, 1, 5, 8, 9, 9, 27]\nIf you have an even set of numbers, average the middle two to find the median. For example, the median of this set of numbers is 28.5 (28 + 29 / 2).\n23, 24, 26, 26, 28, 29, 30, 31, 33, 34\n\n\n--- Slide 59 ---\n\nFlowchart for Median without using inbuilt functions\n\n\n--- Slide 60 ---\n\nMedian – Manual method\n\n\n--- Slide 61 ---\n\nMedian – Statistics Module\n\n\n--- Slide 62 ---\n\nAnalysis - Frequency\n\nmyList=[1, 9, 27, 8, 1, 5, 9]\nFrequency => the number of times a data value occurs\nFrequency of 1 = 2\nFrequency of 9 = 2\nFrequency of 27 = 1\nFrequency of 8 =1\nFrequency of 5 = 1\n\n\n--- Slide 63 ---\n\nGetting the Frequency\n\n\n--- Slide 64 ---\n\nAnalysis - Mode\n\nmyList=[1, 9, 27, 8, 1, 5, 9,1]\nMode => The value that appears the most in the dataset. (the value with the greatest frequency)\nSort the list into ascending order: [1,1,1,5,8,9,9,27]\nThe Mode is 1.\n\n\n--- Slide 65 ---\n\nFirst get the frequency of each item on the list (code on previous slide)\n\nGetting the Mode – Manual method\n\n\n--- Slide 66 ---\n\nGetting the Mode – Statistics Module\n\n\n--- Slide 67 ---\n\nStages of Analytics -> Visualisation\n\nVisualisation helps us to understand the data\nVisualisation is the visual representation of the data using graphs and charts.\nWe will use the module matplotlib\n\n\n--- Slide 68 ---\n\nStages of Analytics -> Visualisation\n\nThe import uses pyplot from the matplotlib module. This is used for to create simple graphs/charts.\nmatplotlib.pyplot is assigned the shorter name plt\n\n\n--- Slide 69 ---\n\nStages of Analytics -> Visualisation\n\nIn this example plt.plot takes in 1 list as an argument, myList. \nIt can take in more than one list. e.g  plt.plot(names,numBS)\nThe .plot() uses the values in myList as the y-axis values.\nIn this example, there are no x-axis values, the pyplot interface uses the list index number 0,1,2,3 ….etc as the x values\n\n\n--- Slide 70 ---\n\nStages of Analytics -> Simple Plot with no Labels\n\n\n--- Slide 71 ---\n\nVisualisation – Labelling the graph\n\n\n--- Slide 72 ---\n\nVisualisation – Simple Plot with Labels\n\n\n--- Slide 73 ---\n\nVisualisation – Options\n\nSometime a line is not suitable for what you want to display.\nA line between point suggests the data is linked in some way\nThe following code plots the points without any connecting lines\n\n\n--- Slide 74 ---\n\nVisualisation – Options\n\n\n--- Slide 75 ---\n\nVisualisation – Options\n\nThe line style consists of two or three characters. The first represents the colour and the second/third indicates the point style\n\n\n--- Slide 76 ---\n\nVisualisation – Working with the X and Y axis\n\nIf no x-axis labels are supplied by the coder, pyplot uses the index of the list for the x-axis values. How could we get the students’ names on the graph?\n\n\n--- Slide 77 ---\n\nVisualisation – Working with the X and Y axis\n\nTo get the names of students onto the graph, use another list`. In this example called names\n\n\n--- Slide 78 ---\n\nVisualisation – Working with the X and Y axis\n\nThe first argument in .plot() is the list names. This represents the x-axis labels.\nThe second argument in .plot() is the list numBS. This represents the y-axis values.\n\n\n--- Slide 79 ---\n\nVisualisation – names used as x-axis labels\nnumBS is y-axis values\n\n\n--- Slide 80 ---\n\nTasks Pg 88\n\nTask 1 -> Create a list of 20 numerical values, then:\nCreate a plot\nAdd a y-axis label\nAdd a title\nShow the plot\nSave the plot image\nTask 3 -> Create a python program with 2 lists, one containing the names of 6 students and the other containing the heights of the 6 students in meters.\nCreate a plot with red dots (not the default blue line) with the heights on the y-axis and the names on the x-axis. Add a title and show the plot.\nTask 4 -> Repeat the above but create a barchart\n\n\n--- Slide 81 ---\n\nVisualisation – Barchart\n\n\n--- Slide 82 ---\n\nVisualisation – Barchart\n\nThe first argument in .bar() is the list names. This represents the x-axis labels.\nThe second argument in .bar() is the list numBS. This represents the y-axis values.\n\n\n--- Slide 83 ---\n\nVisualisation –  Bar Chart\n\n\n--- Slide 84 ---\n\nVisualisation - Scatterplot\n\n\n--- Slide 85 ---\n\nVisualisation –  Scatter Plot\n\n\n--- Slide 86 ---\n\nVisualisation – Pie Chart\n\n\n--- Slide 87 ---\n\nVisualisation –  Pie Chart\n\n\n--- Slide 88 ---\n\nVisualisation – Display 3 data sets on the same graph\n\nIt can be useful to have 2 or more plots overlayed on the same graph. \nThis allows us to compare both plots and examine any trends or relationships that may be there.\nWhen comparing 3 lists, we assume that the items at each list index position correspond with each other. For example, the items at list indices control[0], fertil1[0] and fertil2[0] are assumed to all correspond to 7days;  control[1], fertil1[1] and fertil2[1] all correspond to 14 days etc.\n\n\n--- Slide 89 ---\n\nVisualisation – Display 3 data sets on the same graph\n\n\n--- Slide 90 ---\n\nVisualisation comparing 2 or more datasets\n\n\n--- Slide 91 ---\n\nVisualisation – Display 3 data sets on the same graph\n\n\n--- Slide 92 ---\n\nVisualisation comparing 2 or more datasets\n\n\n--- Slide 93 ---\n\nThe Brief:\n\nHypothesising, making predictions, examining evidence, recognising patterns and reaching conclusions are at the heart of Computer Science. In this applied learning task, students will identify an interdisciplinary topic, develop a hypothesis and utilise existing resources to highlight the salient information and inform future decisions. By identifying, analysing, and deconstructing a problem, students will deepen their understanding of core practices and principles of Computer Science.\n\n\n--- Slide 94 ---\n\nTeam Members\n\n\n--- Slide 95 ---\n\nThe Task\n\nFirst identify an interdisciplinary topic where data analytics would be useful. This might mean collecting data for a scientific experiment, looking at population statistics, historical data, vocabulary use in English, surveying your classmates or even analysing social media posts. These are just a few ideas, look across your other subjects and you're likely to have lots of options. Remember you're looking for datasets that you can find the mean, median, mode and frequency of. Idealy It's best to choose something you'd like to gain a better insight into, that's where data analytics is most useful!\n\n\n--- Slide 96 ---\n\nStep 1:\n\nDefine the topic, data source and make a hypothesis.\n\n\nBrainstorm a few ideas for topics with your team before you decide on your topic:\n\n\n--- Slide 97 ---\n\nStep 1:\n\nDefine the topic, find your data source and make a hypothesis.\nFind your data source\n\nhttps://think.cs.vt.edu/corgis/csv/\n\nhttps://www.kaggle.com/datasets\n\nhttps://www.dataquest.io/blog/free-datasets-for-projects/\n\n\n--- Slide 98 ---\n\nStep 1:\n\nDefine the topic, find your data source and make a hypothesis.\nDescribe the data source, where you got it from and where you stored it.\nExample:\nfocusireland.ie. The number of homeless people in Ireland over the course of 3 years from November 2014 - November 2017. Stored in a .csv file in the same folder as the Python Script.\n\n\n--- Slide 99 ---\n\nStep 1:\n\nDefine the topic, find your data source and make a hypothesis.\nMake a hypothesis:\n\nAn Example: The number of people that are homeless in Ireland has been steadily increasing over the past few years from November 2014 - November 2017 Our hypothesis is that homelessness is steadily increasing annually.\n\n\n--- Slide 100 ---\n\nBreak down the problem into sequential steps that need to be achieved to complete this task.\n\nRecommended order:\n-Source, Collect, Clean and Transform Data\n-Algorithms for Processing Data \n-Data Visualisation \n- Data Interpretation\n\n\n--- Slide 101 ---\n\nStep 2:\n\nStep 2:   Source, Collect, Clean and Transform Data\n\nNow that you have selected your topic it's time to gather/collect data. Make sure to save the data somewhere safe so that you have access to it (if it's not that big you can add it as an addition on your webpage\n\nOnce you have your data it might need to be cleaned prior to analysis. What format is it currently stored in, .xlsx, .csv, .txt, does it need conversion? Are there characters/symbols you need to remove? Would the data be best stored in a list  ?\n\n\n--- Slide 102 ---\n\nStep 2:\n\nStep 2:   Source, Collect, Clean and Transform Data\n\nOutline the methods and functions you used to clean and transform your raw data (this can include using desktop applications and/or coding techniques), excel etc.\nExample:\nThe dataset was large. We removed any rows we did not need from the dataset using MS Excel. We then used MS Excel to remove dollar signs and  commas in numerical data.  We read the .csv file and then split it into separate integers (in a list) ready for finding the averages.\n\n\n--- Slide 103 ---\n\nStep 3:\n\nStep 3:   Algorithms for Data Processing\n\nDescribe the algorithms you used and why? \n\nExample:\nWe used the mean and median algorithms in the program as they were the most relevant to the data\n\n\n--- Slide 104 ---\n\nStep 4:\n\nStep 4:   Visualisation\n\nDescribe the graphical output type you chose and why? \nInclude an images of the charts / graphs.\nNow that you have your data processed it's time to visualise it to make it easier to interpret. There are many ways to visualise your data, be sure to choose the options that will make analysing the data easiest.\n\n\n--- Slide 105 ---\n\nStep 4:\n\nStep 4:   Data Interpretation\n\nNow that you have your data processed and visualised it's time to use some human brain power to intepret the findings!\n\nWhat have you learnt from the data, how does it compare with your hypothesis and what future predictions or decisions will it effect?\n\n\n--- Slide 106 ---\n\nStep 4:\n\nStep 4:   Data Interpretation\n\nWhat have you learnt from the data, how does it compare with your hypothesis and what future predictions or decisions will it effect?\n\nExample:\nWe have learned that the levels of theft arrests made in Mountjoy Prison fluctuated between 2003 and 2016, with a peak in 2003 and a low in 2007. This did not fit our hypothesis. Around times of recession, theft rates increased, for example from 2007 to 2013. They also fell during times of economic wellbeing.\n\n\n--- Slide 107 ---\n\nStep 5:\n\nStep 5:   Write your report\n\nYou must include your code, datasets, graphs & plots as part of your html report.\n\nRemember to comment your code to explain what is happening in your code\n\nSUBMIT your report, code, datasets, graphs and plots",
          "file": "Notes/18 - Data Analytics.pptx"
        },
        {
          "id": "24",
          "title": "Modelling&Simulation",
          "content": "--- Slide 1 ---\nModelling and Simulation\nComputer Science – ALT3\n\n--- Slide 2 ---\nWhat is a computer Model?\nA model is a representations of a real-world event, system, behavior, or natural phenomenon, such as the workings of a nuclear reactor or the evacuation of a football stadium.\n\n--- Slide 3 ---\nWhat is a computer model?\nA collection of rules is created to study what would happen in real-life situations. Changes are made to see how they affect the outcome. For example, before a new football stadium is built, a computer model could be used to see if there are enough fire exits and if they’re in the safest places.\n\n--- Slide 4 ---\nWhat is a computer model?\nA collection of rules is created to study what would happen in real-life situations. Changes are made to see how they affect the outcome. For example, before a new football stadium is built, a computer model could be used to see if there are enough fire exits and if they’re in the safest places.\n\n--- Slide 5 ---\nSimple Models can be built on a spreadsheet (excel)\nSimple models can be built in a spreadsheet. A spreadsheet model could be used to plan a school prom. To make sure it came in on budget the spending on food, drinks, entertainment, and the price of tickets could be varied.\n\nIt could also be used to see how much money would be made from ticket sales. These are called 'what if…' questions, for example:\n\nWhat if only 20 people attend?\nWhat if costs go up by 10 per cent?\n\n--- Slide 6 ---\nhttps://www.youtube.com/watch?v=M0iZ52kUOiQ\n\n--- Slide 7 ---\nWhat is simulation?\nSimulation is a type of computer model. A simulation imitates a particular environment. It can be used for research or training\nThey allow different scenarios to be tested. These scenarios can be an actual or probable real-life events that: \nfind a cause of a past occurrence (such as an accident), \nforecast future effects (outcomes) of assumed circumstances or factors.\n\n--- Slide 8 ---\nSimulation in real-life?\nEver wonder how pilots practice flying before climbing into the cockpit?\nWell they use very advanced simulation software to train in all sorts of conditions.\n\n--- Slide 9 ---\n(no extractable text)\n\n--- Slide 10 ---\nBuilding a basic model in python\nAccording to the Census 2021 Northern Ireland Population is 1,903,175 and :\n45.7% of inhabitants are Catholic / Catholic background\n43.48% from Protestant or other Christian background\n\nThe 2011 census figures were 45% Catholic and 48% Protestant\nPrepare a model for the increase and decrease in population over the next 10 years, 20 years, 50 years\n\n--- Slide 11 ---\nSolution to the previous problem – Pg 1\n\n--- Slide 12 ---\nSolution to the previous problem – Pg 2\n\n--- Slide 13 ---\nSolution to the previous problem – Pg 3\n\n--- Slide 14 ---\nModel of the population of a town\nCarrick Population \nPrepare a model for the increase and decrease in population of Carrick (current population 1,535) year-by-year. Given the following details: \nBirths: 3% of the population per year \nDeaths 2% of the population per year \nThe model can be an interactive Python program.\nWhen you have completed the above you may extend the problem: People leaving: 3 equally likely scenarios depending on Economic factors: \n1. 100 net people coming in. \n2. 50 net people coming in. \n3. 200 net people leaving.)\nUse the previous example’s code and modify it\n\n--- Slide 15 ---\nEvaluating a compound interest model\nThe next model has a mathematical core and is used to calculate the compound interest\n\n--- Slide 16 ---\nRunning Simulations and evaluating models\n\n--- Slide 17 ---\nEvaluate the model\n\n--- Slide 18 ---\nRunning Simulations and evaluating models\n\n--- Slide 19 ---\nRunning Simulations and evaluating models\n\n--- Slide 20 ---\nImproving  this compound interest model\nFurther modification of the model would allow us to find the most suitable loan deal for a user, given the user’s salary as a representation of their ability to pay back the loan.\n\nFront-end Debt To Income measures how much of your monthly gross (pre-tax) income goes toward your mortgage payment (both principal and interest. Mortgage lenders want their borrowers to be able to keep this below 28%.\n\nImprove the previous model by inputting the yearly gross salary, calculate the monthly gross income and check if the Debt to Income is below 28%. Print the result to screen in a user friendly format\n\n--- Slide 21 ---\nModel extended to check for loan eligibility\n\n--- Slide 22 ---\nDecision Making Models\nThis tennis data set comes from a famous introductory model problem.\n\nIt shows the weather conditions on different days and whether or not it is suitable for playing tennis\n\nWe will use this data to model a tennis player’s decision making based on a weather scenario. \n\nThis model has FOUR attributes involved in the decision\nOutlook\nTemperature\nHumidity]\nWind\n\n--- Slide 23 ---\nDecision Trees\nIn the tennis data set, it is not easy to identify the scenarios. The logic is not clear. One way to approach this problem is with a Decision Tree\nA Decision tree allows us to identify all possible decision making paths, making it easier to write the conditions in the code\nEach branch from the from the root at the top to a leaf at the bottom represents the decision that lead to a particular outcome\n\n--- Slide 24 ---\nTennis Decision Tree\nStart by putting the first attribute outlook at the top. There are 3 possible values for outlook: sunny, overcast, rain\nThe next step is examine the data to find out what happens for each of these outlook values\nIf sunny, sometimes the player plays and sometimes not. The decision must depend on some other attribute\nIf overcast, the player plays tennis. The other attributes do not affect the decision\nIf raining, sometimes the player plays and sometimes not. The decision must depend on some other attribute\n\n--- Slide 25 ---\nTennis Decision Tree\nWhen raining, the player plays what ever the temperature. There is no data for when it is hot so we can ignore this\nWhen raining, when humidity is high or not the player may or may not play. We can ignore this \nWhen raining, when the wind is weak, the player plays but if wind is strong the player does not play. This variable is significant for player decision\n\n--- Slide 26 ---\nDecision Tree\nThe starting point of the tree is always the root. It contains the first attribute, outlook. The other attributes are in the boxes below. The values for each attribute are connected from the root to the leaves using branches.\nEach branch from root to leaf represents a decision making path\nA major benefit of Decision Trees are they are easy to understand and follow.\nIt is now possible to write python code for this decision tree. We can use conditionals (if, elif, else) with and or or operators, or nested conditionals.\n\n--- Slide 27 ---\nThe code for the decision tree\nStart with the function definition and it has 3 attributes : outlook, humidity and wind\n\n\n we can start with the most straight forward conditional, overcast:\n\n--- Slide 28 ---\nThe code for the decision tree\nStart with the function definition and it has 3 attributes : outlook, humidity and wind\n\n\n we can start with the most straight forward conditional, overcast:\n\n--- Slide 29 ---\nThe code for the decision tree\nNext, we look at when the outlook is sunny. The decision to play also depends on another attribute humidity.\nIf outlook is sunny and humidity high, the decision to play is no\nIf outlook is sunny and humidity low, the decision to play is yes.\n\n--- Slide 30 ---\nThe code for the decision tree\nFinally look at the decision path for raining. Rain is affected by another attribute wind.\nIf outlook is rain and wind is strong, decision to play is no\nIf outlook is rain and wind is weak, decision to play is yes\n\n--- Slide 31 ---\nThe code for the decision tree\nEvaluate the model using one example with an expected result of no\n\n--- Slide 32 ---\nTask 1\nA mechanic has to check the parts in a machine. They must decide what to do about each part in terms of maintenance. The problem is described in the decision tree.\nDevelop a python function with two arguments to determine which of the following actions to take:\nNo problem, do nothing\nApply lubricant\nApply tape\n\n--- Slide 33 ---\nTask 2\nThis decision tree was developed for automatically classifying fruit, based on several attributes.\nUse a python function, develop a computer model for automatic classification of fruit, based on this decision tree\n\n--- Slide 34 ---\nAgent Based Modelling (HL)\nAgent based modelling(ABM) involves building models to simulate the actions and interactions of individual “agents” within an environment.\nThese agents are autonomous and independent of each other and the environment. This means that the environment contains multiple models, each of which is an agent.\nABM allows us to simulate the behaviours of the agents to investigate how specific attributes of an agent may affect other agents or the environment as a whole.\nhttps://www.youtube.com/watch?v=Z8Wf1vF_xgQ\nhttps://www.youtube.com/watch?v=n6h3WiRLmp8\n\n--- Slide 35 ---\nReal World ABM Exampes - HL\n\n--- Slide 36 ---\nAnt Model Pattern Example\n\n--- Slide 37 ---\nAnt Model\nEach ant must have an initial state, which could be randomly generated or have a default value e.g work to be done set to yes or no.\nThe rules might be as follows:\nIf ant is hungry the ABM will get the ant to go find food\nIf ant is Not hungry and there is work to be done, the ant must go to work\nIf there is no work to do and the ant is not hungry it will join another group of ants and will walk around in an army\nTherefor each ant is responsible for his own actions -> it is autonomous\nNext we can add models for multiple agents\nThis Photo by Unknown Author is licensed under CC BY-NC-ND\n\n--- Slide 38 ---\nAnt Model continued\nThe starting conditions for the environment could be set, or generated at random. E.g. if there is plenty of food close to an ant, I will not take long to find the food so it can spend more time working.\nThis could be used to simulate the productivity of the environment when food is plentiful and widely dispersed. This could be compared to productivity when food is scare and concentrated in just one location\nThis Photo by Unknown Author is licensed under CC BY\n\n--- Slide 39 ---\nBenefits of Agent Based Modelling\n\n--- Slide 40 ---\nABM and Emergent Behaviour\n\n--- Slide 41 ---\nExamples of ABM\n\n--- Slide 42 ---\nExcellent introduction to Agent Based Modeling (its 2 hours long)\nhttps://www.youtube.com/watch?v=clPu6wMuLfg\n\n--- Slide 43 ---\nAgent Based Modelling Toolkits\nhttps://www.youtube.com/watch?v=QtZ3M5UNKhI",
          "file": "Notes/24 - Modelling&Simulation.pptx"
        },
        {
          "id": "25",
          "title": "Software Development Process",
          "content": "--- Slide 1 ---\nThe Software Development Process\nLeaving Cert Computer Science\n\n--- Slide 2 ---\nIntroduction\nThe terms software engineering and software development are used interchangeably. \nThe term software engineering was coined by Margaret Hamilton who led a team that developed the flight software for the NASA Apollo program in 1960’s.\nMost software development projects follow an organised, structured process because this results in a greater chance of:\nMeeting the needs of the user\nKeeping the cost of development within budget\nDelivering the software on time\nMinimising the cost of maintenance\n\n--- Slide 3 ---\nIntroduction\nWhen developing a solution to a problem for a computer system, programmers work through a number of distinct stages. \nCollectively, these stages are known as the Software Development Lifecycle (SDLC).\nThe arrangement of these stages and how programmers move from one stage to another, is known as the Software Development Methodology\nThe 2 main methodologies you need to be aware of are:\nWaterfall\nAgile\n\n--- Slide 4 ---\nThe Client and the user\nThe client is the person in an organisation who has commissioned the software project\nThe User, the individual(s) who will actually be using the software\n\n--- Slide 5 ---\nStages of Software Development Life Cycle\n\n--- Slide 6 ---\nStage 1 -> Investigate (Analyse)\nUnderstand the problem: the developers need to know what they're trying to solve. They figure out what the software needs to do, who will use it, and what problems it should solve.\nResearch: Next, they look at similar projects or existing solutions to gather ideas and learn from them. This helps them avoid repeating mistakes and find better ways to approach the problem.\nGather Requirements: This step involves talking to the people who will use the software (BOTH clients and end-users) to understand their needs and preferences. They ask questions to clarify what features the software should have and how it should work.\n\n--- Slide 7 ---\nStage 1 -> Investigate (Analyse)\nHardware and Software Requirements: An initial assessment of the most suitable hardware and software to be used is made\nCarry out a feasibility study: The developers check if what the client wants is possible within the available resources like time, budget, and technology. A report is written for the client giving an opinion as to whether a feasible solution to the problem is possible.\n\n--- Slide 8 ---\nStage 2 -> Plan\nA software development plan is necessary to ensure that everyone concerned understands clearly what must happen, when and by whom, in order to complete the new software system. \n\nTimescales: A timeline or schedule is made to outline when each part of the project should be completed. This helps keep everyone on track and ensures the project stays on schedule.\nAssign Tasks: Roles and responsibilities are defined, and tasks are assigned to different team members based on their skills and expertise.\nBudgeting: The budget for the project is planned out, including costs for resources, tools, and personnel.\n\n--- Slide 9 ---\nStage 3 -> Design\nThere are many different approaches to software design, each with their own advantages and disadvantages. Not all of these approaches are used on any given project.\nTop Down Design -> A top-down design approach starts with the main system at the top and breaks it down into smaller units, in a hierarchical fashion. Each unit is broken down until each aspect is manageable. This is an example of DECOMPOSITION\n\n--- Slide 10 ---\nStage 3 -> Design\nModular Design -> This a software design approach where a system is divided into a set of smaller, independent software modules. Each module is responsible for a distinct aspect of the system’s functionality and can be developed, tested, and maintained separately. \nThe benefits of Modular Design are:\nThe modules of code can be re-used, even on other projects.\nEach module is relatively small so problems and bugs are easier to find and fix. \nThe design of the system as a whole is easier to understand, and manage.\n\n--- Slide 11 ---\nStage 3 -> Design\nUser Interface Design: This is like designing the layout and appearance of rooms in a house. Designers figure out how users will interact with the software, like where buttons will be placed and how screens will look.\nFlowcharting : This can be used at the design stage to represent the flow of operation of the system. Flowcharts provide a clear way of communicating the software solution visually. This results in:\nA shared understanding on the part of the team and users\nA means of checking that the development process is correct\nA way of identifying and getting rid of unnecessary steps.\n\n--- Slide 12 ---\nStage 3 -> Design\nPrototyping : Sometimes, designers create prototypes, which are like rough drafts or models of the software. This helps them see how things will work and get feedback from users and clients before building the final product.\nDescription of Algorithms -> All the main functionalities that the software will require should be listed and their algorithms described. The descriptions can be written in pseudocode, normal language or flowcharts\nData Tables -> A data table lists all the data to be used, its type and how it will be stored.\nVariables Tables -> A variable table can be created to list all the variables that the software will need, and to decide on the name, type, and length of each one.\n\n--- Slide 13 ---\nStage 3 -> Design -> USER CENTRED DESIGN\nUser centered design gives top priority to the needs of the user. It is important the user can use the software as effectively as possible. The users themselves should be involved to make sure the software is useable by ALL users. \nTwo important considerations for user-centered design are: \nUSER EXPERIENCE (UX)\nUNIVERSAL DESIGN\n\n\nVideo on User Centred Design\n\n--- Slide 14 ---\nStage 3 -> Design -> USER CENTRED DESIGN\nUSER EXPERIENCE \nThis is the experience of the user when interacting with the product or software. This includes perception, preferences, emotions and other factors before, during and after use. A key part of user experience is the USER INTERFACE (UI). This could be the physical buttons and dials on a washing machine or the  graphical interface of an operating system or website. \nUNIVERSAL DESIGN (UD)\nThis can be applied when designing anything from a car, to furniture to software. Universal design is the process of designing a product so that everyone can understand, access and use it, regardless of their age, size or ability.\n\n--- Slide 15 ---\nStage 3 -> Design -> Universal Design\nVideo on universal design\n\n--- Slide 16 ---\nStage 3 -> Design -> Adaptive and Assistive Technology\nAdaptive Technologies -> provide features to existing technologies to aid their use specifically for people with impairments and disabilities, and older people. Adaptive technologies would RARELY be used by non-disabled people. Examples are screen-readers, alternative keyboards and text-to-speech synthesizers. \nAssistive Technology - > this refers to something that can help people with disabilities, but also may be used by the non-disabled. An example is the Microsoft Windows Magnifier app which allows users to magnify anything on-screen\n\n--- Slide 17 ---\nStage 4 -> Create\nThis is the stage the software is actually written AND tested. The programmers create the system based on all the work that has been carried out during the previous stages. \nThe design of the system may be changed as a result of an issue that happens during its coding. This is another example of iteration, where you loop back to an earlier stage.\nSuch iteration can cause delays to the programming schedule.\n\nTesting will be carried out during the Create Stage\n\n--- Slide 18 ---\nStage 4 -> Create (The General Steps in Testing)\nRequirement Understanding:  Testers need to understand what the software is supposed to do. This involves reading the requirements documents or discussing with stakeholders to know the expected behavior of the software.\nTest Planning: Testers plan how they're going to test the software. They decide what to test, how to test it, and what resources they'll need.\nTest Case Design: Testers create specific scenarios, called test cases, that they'll use to check if the software behaves as expected. These test cases include steps to follow and expected results.\nTest Execution: Testers actually run the test cases. They interact with the software, input data, and observe the output to see if it matches what's expected.\n\n--- Slide 19 ---\nStage 4 -> Create (The General Steps in Testing)\n5.\tDefect Reporting: If testers find any issues during testing, they report them. They provide details like what they did, what went wrong, and how severe the issue is.\n6.\tDefect Resolution: Developers fix the reported issues. Testers verify these fixes to make sure they work correctly and don't cause new problems.\n7.\tRegression Testing: Testers re-run previous tests to ensure that the fixes and changes haven't broken anything else in the software. This helps maintain overall quality.\n8.\tTest Closure: Once testing is complete and the software meets the desired quality standards, testers document the results and close out the testing process.\nThese steps form a cycle, and they may be repeated multiple times during the software development lifecycle to ensure the software meets user expectations and quality standards.\n\n--- Slide 20 ---\nStage 4 -> Create (Unit Testing & Integration Testing)\nUnit Testing\n Individual components or units of code are tested in isolation to ensure they work correctly. Each unit, like a function or method, is tested independently to verify that it produces the expected output for a given input. Unit tests help developers catch bugs early, maintain code quality, and ensure that each piece of code functions as intended before integrating it into the larger software system.\nIntegration Testing\nIntegration testing is like assembling a puzzle to see if all the pieces fit together. It's a testing technique in software development where individual units or components of a system are combined and tested as a group to ensure they interact correctly. The focus is on verifying that the interfaces between these components work as expected and that they communicate and exchange data properly.\n\n--- Slide 21 ---\nStage 4 -> Create (White Box Testing)\nWhite Box Testing or Structural Testing\nImagine you’re an electrician tasked with checking the wiring in a house. White Box Testing is like having the complete blueprint of the house, including all the hidden electrical circuits, outlets, switches, and even the color coding of the wires. You’re not just checking if the lights turn on when you flip the switch (that would be more like Black Box Testing), but you’re examining the actual wiring behind the walls.\nWhite Box Testing, or structural, code-based, or glass box testing, is a software testing technique that focuses on the software’s internal logic, structure, and coding. It provides testers with complete application knowledge, including access to source code and design documents, enabling them to inspect and verify the software’s inner workings, infrastructure, and integrations.\n\n--- Slide 22 ---\nStage 4 -> Create (Functional Testing)\nFunctional Testing also known as Black Box Testing\nSoftware functional testing involves verifying that a piece of software or an application meets its functional requirements. In other words, it ensures that the software performs the specific functions it's designed to do accurately and reliably.\n\nDuring functional testing, testers typically focus on testing individual features or functionalities of the software to confirm that they behave as expected. This can involve testing various inputs and scenarios to ensure that the software responds correctly and produces the expected outputs.\n\nFunctional testing is often carried out through a combination of manual testing, where testers interact with the software directly to validate its behavior, and automated testing, where scripts are created to simulate user interactions and verify expected outcomes automatically.\n\n--- Slide 23 ---\nStage 4 -> Create (System Testing)\nSystem Testing\nSystem testing differs from functional testing in that it tests the entire system while functional testing only tests a single function or feature at a time.\nThe aim of system testing is to ensure the software meets the client and users requirements.\nSystem testing can be broken down into ALPHA and BETA testing\nAlpha testing refers to testing the software in-house. It aims to test as many paths through the system as possible in order to discover problems and fix them before the system is tested by users.\nBeta testing occurs when an early version of the software is sent to potential users for testing. Users perform tests that are typical of what would take place in real life conditions. They record any problems that they find and notify the developers who must then rectify the problem\n\n--- Slide 24 ---\nStage 4 -> Create (Non-functional Testing)\nNon-functional Testing\nPurpose: Non-functional testing evaluates the performance, reliability, usability, and other non-functional aspects of the software system. It ensures that the software meets quality attributes beyond just its functional requirements.\nFocus: It focuses on characteristics like performance, reliability, security, usability, scalability, and maintainability.\nExamples: Load testing, stress testing, security testing, usability testing, reliability testing, and compatibility testing are all examples of non-functional testing. These tests evaluate how the system behaves under various conditions and assess its compliance with non-functional requirements.\n\n--- Slide 25 ---\nStage 4 -> Create (Acceptance Testing)\nAcceptance Testing\nFirstly, programs are tested with normal, erroneous and boundary data. \nThen, unit testing, module testing, and system testing is carried out. \nThen, the system is tested whether it meets the user’s requirements. This is called acceptance testing. \nThe test data supplied to the acceptance data is supplied by the end-user instead of the data used for testing purposes. \nThe system is also tested in an environment where a realistic volume of data is supplied. This is a part of the hand-over process and is carried out by the intended user.\n\n--- Slide 26 ---\nStage 5 -> Evaluate\nWhen the testing is over, a broader evaluation of the system should take place. This evaluation compares the finished system with the specifications of the requirements.\nThis phase comes to action three to six months after the software has come to use. \nThis time duration allows the user and organisation to get used to the new software environment. \nUser may identify a few shortcomings at this stage and their feedback is evaluated. \nThe software must be effective in solving the problem, easy to use and easy to maintain.\n\n--- Slide 27 ---\nStage 6 -> Document\nEffective communication is key to the success of any software project. This includes meetings and phones calls as well as more formal documentation. \nThe specific documents produced will vary from project to project.This will include:\nFeasibility Study\nSpecifications of Requirements\nProject Plan\nDesign Documents\nThe code itself with comments andsupporting technical documentation\nTest Plans & Test Data & Test Results\nSystem Documentation of the final version\nInstallation & set-up guide\nTraining & End-user documents\nEvaluation Report\n\n--- Slide 28 ---\nAgile Software Development Methodology\nImagine building a house. Instead of planning every detail upfront and building it all at once, Agile is like building one room at a time, getting feedback from the homeowner as you go.\n\nIn software development, Agile means breaking the project into small pieces called \"sprints.\" Each sprint typically lasts a few weeks, and the team works on a specific set of tasks during that time. After each sprint, there's a review where the team and stakeholders give feedback, and adjustments are made for the next sprint. This way, the software evolves gradually, adapting to changing needs and priorities along the way. It's like taking small steps forward, always ready to adjust course based on feedback.\n\n--- Slide 29 ---\nAgile Software Development Methodology\nPros of Agile Methodology:\n\nFlexibility: Easily adapts to changes in requirements and priorities.\nFaster Delivery: Incremental development leads to quicker delivery of working software.\nStakeholder Engagement: Regular collaboration ensures alignment with customer needs.\nContinuous Improvement: Iterative approach allows for ongoing enhancements and feedback.\nReduced Risks: Early detection and mitigation of issues lead to minimized project risks.\n\n--- Slide 30 ---\nAgile Software Development Methodology\nCons of Agile Methodology:\n\nLack of Predictability: Difficulty in estimating timelines and project costs accurately.\nResource Intensive: Requires active participation and commitment from all team members.\nDependency on Customer Availability: Relies on consistent feedback and involvement from stakeholders.\nDocumentation Challenges: Emphasis on working software over comprehensive documentation can lead to insufficient documentation.\nScope Creep: Susceptible to the addition of new features or requirements throughout the development process, potentially impacting project scope and deadlines.\n\n--- Slide 31 ---\nWaterfall Software Development Methodology\nWaterfall software development is a traditional approach to creating software that follows a sequential, linear process. In the waterfall model, each phase of development must be completed before moving on to the next phase, similar to water flowing downward in a waterfall.\nWaterfall development is characterized by its rigid structure and emphasis on extensive upfront planning and documentation. While this approach can provide clarity and predictability, it can also be less flexible and less responsive to changes compared to Agile methodologies. Issues or changes discovered late in the process can be more difficult and costly to address in a waterfall model.\n\n--- Slide 32 ---\nWaterfall Software Development Methodology\nPros of Waterfall Software Development:\n\nClear Structure: The sequential nature of waterfall development provides a clear roadmap for the entire project, making it easier to plan and manage.\nEarly Documentation: Requirements and design documentation are established upfront, providing a comprehensive understanding of the project scope and objectives.\nPredictability: Waterfall development often results in more predictable timelines and budgets, as each phase is completed before moving on to the next.\nStakeholder Involvement: Stakeholders have a clear understanding of the project's progress and can provide input at each stage.\n\n--- Slide 33 ---\nWaterfall Software Development Methodology\nCons of Waterfall Software Development:\n\nLimited Flexibility: Changes in requirements or priorities can be difficult and costly to implement once the project is underway, as each phase must be completed before moving on to the next.\nLate Feedback: Stakeholders may not see the software until late in the development process, leading to potential misunderstandings or misalignments with expectations.\nRisk of Requirements Errors: Since all requirements are gathered upfront, there's a risk of overlooking or misunderstanding key requirements, which may not be discovered until later stages.\nDifficulty Managing Complex Projects: Waterfall is less suited for large, complex projects where requirements may evolve over time or where there's a need for rapid iteration and feedback.\n\n--- Slide 34 ---\n(no extractable text)\n\n--- Slide 35 ---\nRoles in a Software Development Team\nProject Manager\nInvolved in producing the feasibility study and the specification of requirements\nForms the project team and the supervises their work\nEnsures that the workloads are properly allocated\nMonitors everyone’s progress and ensure the project stays on track both timewise and financially\nMain point of communication between the client and the development team and regularly communicates with both parties to ensure any problems are reported and sorted out\n\n--- Slide 36 ---\nRoles in a Software Development Team\nBusiness Analyst\nInvolved in the Investigation Stage, before the rest of the team is formed\nA business analyst acts like a bridge between the technical side of things and the business goals. They talk to different people, like clients or end users, to understand what they need from the software. Then, they translate those needs into requirements that the development team can understand and work on. They're kind of like detectives, investigating what the software should do and making sure everyone's on the same page before the development work starts.\n\n--- Slide 37 ---\nRoles in a Software Development Team\nSystems Analyst\nInvolved in the Investigation Phase, before the rest of the team is formed\nA system analyst is like a detective who investigates how different parts of a software system should work together. They talk to users, study existing systems, and figure out what changes or improvements are needed. Then, they create detailed plans and diagrams to guide the development team in building the right solution. They're like architects, designing the blueprint for the software before it's built.\n\n--- Slide 38 ---\nRoles in a Software Development Team\nDesigner\nDesigns the software to meet the specification\nProduces the design documentation\n\n--- Slide 39 ---\nRoles in a Software Development Team\nDeveloper\nWrites the code\nMaintains backup copies of the programs\nCarries out unit testing\nProduces the software documentation\n\n--- Slide 40 ---\nRoles in a Software Development Team\nTester\nProduce the test plans and the test data\nCarries out all the testing\nDocuments all the test results and make sure they are reported to the developers.",
          "file": "Notes/25 - Software Development Process.pptx"
        }
      ]
    }
  ]
}